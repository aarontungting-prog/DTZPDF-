<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>éœ“è™¹è¥¿æ´‹æ£‹ï¼šé€£ç·šå°æˆ°ç‰ˆ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/objects/Sky.js"></script>

    <script type="importmap">
    {
        "imports": {
            "firebase/app": "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js",
            "firebase/database": "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js",
            "firebase/auth": "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js"
        }
    }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; -webkit-user-select: none; user-select: none; }
        
        /* UI å±¤ç´šè¨­å®š */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; }
        .hud-element { pointer-events: auto; padding: 15px; }

        /* é ‚éƒ¨è³‡è¨Šåˆ— */
        .top-bar {
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            display: flex; justify-content: space-between; align-items: flex-start;
            padding-top: 10px;
        }
        .status-box { text-align: right; text-shadow: 0 0 5px #000; }
        .status-title { color: #00e5ff; font-weight: bold; letter-spacing: 1px; font-size: 14px; margin-bottom: 2px; }
        .turn-indicator { font-size: 1.4rem; font-weight: 900; color: #fff; transition: color 0.3s; }
        
        /* åº•éƒ¨æ§åˆ¶å€ (æ‰‹æ©Ÿå„ªåŒ–) */
        .bottom-controls {
            background: rgba(0, 0, 0, 0.85);
            border-top: 1px solid #333;
            padding: 15px;
            display: flex; flex-direction: column; gap: 10px;
            backdrop-filter: blur(5px);
        }

        .user-info { color: #aaa; font-size: 12px; display: flex; justify-content: space-between; margin-bottom: 5px; }
        .room-info { color: #00ff00; font-weight: bold; font-size: 14px; text-align: center; margin-bottom: 5px; min-height: 20px; }

        /* æŒ‰éˆ•æ¨£å¼ */
        .btn-group { display: flex; gap: 10px; }
        button {
            flex: 1; border: none; padding: 12px 0; border-radius: 8px;
            font-weight: bold; font-size: 16px; cursor: pointer; color: #000;
            transition: transform 0.1s, opacity 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        button:active { transform: scale(0.96); }
        .btn-create { background: #00e5ff; } /* è—è‰² */
        .btn-join { background: #ff0055; color: white; } /* ç´…è‰² */
        .btn-copy { background: #444; color: #fff; flex: 0.4; font-size: 14px; }

        /* è¼‰å…¥ç•«é¢ */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #050505; z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #00e5ff; transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333;
            border-top: 4px solid #00e5ff; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* æµ®æ°´å° */
        .watermark { position: absolute; bottom: 80px; width: 100%; text-align: center; color: rgba(255,255,255,0.1); font-size: 10px; pointer-events: none; }

        @media (min-width: 768px) {
            .bottom-controls {
                position: absolute; top: 20px; left: 20px; bottom: auto;
                width: 260px; border-radius: 10px; border: 1px solid #333;
            }
            .watermark { bottom: 10px; }
        }
    </style>
</head>
<body>

<div id="loading">
    <div class="spinner"></div>
    <div id="loading-txt">æ­£åœ¨é€£ç·šè‡³ä¼ºæœå™¨...</div>
</div>

<div id="ui-layer">
    <div class="top-bar hud-element">
        <div style="font-size:12px; color:#666;">NEON CHESS <span style="color:#00e5ff;">v2.0</span></div>
        <div class="status-box">
            <div class="status-title" id="connection-status">é€£ç·šä¸­...</div>
            <div class="turn-indicator" id="turn-txt">æº–å‚™ä¸­</div>
        </div>
    </div>

    <div class="bottom-controls hud-element">
        <div class="user-info">
            <span id="player-id">ID: ---</span>
            <span id="ping-txt" style="color:#0f0;">â— Online</span>
        </div>
        <div class="room-info" id="room-display">å°šæœªåŠ å…¥æˆ¿é–“</div>
        
        <div class="btn-group">
            <button class="btn-create" onclick="createRoom()">å‰µå»º (åŸ·ç™½)</button>
            <button class="btn-join" onclick="joinRoom()">åŠ å…¥ (åŸ·é»‘)</button>
        </div>
        <div class="btn-group" style="margin-top:5px; display:none;" id="copy-area">
            <button class="btn-copy" onclick="copyRoomId()">è¤‡è£½æˆ¿è™Ÿ</button>
        </div>
        <div style="font-size:10px; color:#555; margin-top:10px; text-align:center;">
            å–®æŒ‡æ—‹è½‰è¦–è§’ â€¢ é›™æŒ‡ç¸®æ”¾ â€¢ é»æ“Šç§»å‹•
        </div>
    </div>
    <div class="watermark">DTZ STABLE VERSION</div>
</div>

<script type="module">
    import { initializeApp } from "firebase/app";
    import { getDatabase, ref, set, get, update, onValue, onDisconnect } from "firebase/database";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "firebase/auth";

    // 1. ç’°å¢ƒåµæ¸¬èˆ‡åƒæ•¸è¨­å®š
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // æ‰‹æ©Ÿç«¯å¤§å¹…é™ä½æ¸²æŸ“è² æ“”
    const CONFIG = {
        grassCount: isMobile ? 5000 : 60000,   // æ‰‹æ©Ÿè‰é‡æ¸›å°‘ 90%
        treeCount: isMobile ? 100 : 600,       // æ¨¹æœ¨æ¸›å°‘
        shadowSize: isMobile ? 512 : 2048,     // é™°å½±è§£æåº¦é™ä½
        pixelRatio: Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2) // é™åˆ¶æ¸²æŸ“è§£æåº¦
    };

    // 2. Firebase åˆå§‹åŒ–
    const firebaseConfig = {
        apiKey: "AIzaSyCxPppnUG864v3E2j1OzykzFmhLpsEJCSE",
        authDomain: "chess-1885a.firebaseapp.com",
        databaseURL: "https://chess-1885a-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "chess-1885a",
        storageBucket: "chess-1885a.firebasestorage.app",
        messagingSenderId: "824383572856",
        appId: "1:824383572856:web:7c663d6bf0f970f6acd68d"
    };

    let app, db, auth, myUid;
    try {
        app = initializeApp(firebaseConfig);
        db = getDatabase(app);
        auth = getAuth(app);
    } catch(e) { 
        alert("é€£ç·šéŒ¯èª¤ï¼šç„¡æ³•é€£æ¥ä¼ºæœå™¨"); 
    }

    // éŠæˆ²è®Šæ•¸
    let gameId = null;
    let playerColor = 'w'; // w æˆ– b
    let isOnline = false;
    let game = new Chess();
    let scene, camera, renderer, controls, raycaster;
    let tilesMap = {}, piecesMap = {};
    let selectedSquare = null;
    let isProcessing = false;
    let grassMat;
    const BOARD_HEIGHT = 15;

    // ==========================================
    // ğŸš€ è‡ªå‹•ç™»å…¥èˆ‡é€£ç·šé‚è¼¯
    // ==========================================
    
    function autoLogin() {
        signInAnonymously(auth).catch((error) => {
            alert("ç™»å…¥å¤±æ•—: " + error.message);
        });
    }

    onAuthStateChanged(auth, (user) => {
        if (user) {
            myUid = user.uid;
            document.getElementById('loading').style.opacity = 0;
            setTimeout(() => document.getElementById('loading').style.display = 'none', 500);
            document.getElementById('player-id').innerText = `ID: Guest_${myUid.substring(0,4)}`;
            document.getElementById('turn-txt').innerText = "ç­‰å¾…é–‹å§‹";
            
            // æ–·ç·šè‡ªå‹•æ¸…é™¤ç‹€æ…‹ (Presence System)
            const conRef = ref(db, '.info/connected');
            onValue(conRef, (snap) => {
                if (snap.val() === true) {
                    document.getElementById('ping-txt').style.color = "#0f0";
                } else {
                    document.getElementById('ping-txt').style.color = "#f00";
                }
            });
        }
    });

    // ==========================================
    // âš”ï¸ éŠæˆ²æˆ¿å¤§å»³åŠŸèƒ½
    // ==========================================

    window.createRoom = function() {
        if (!myUid) return;
        gameId = Math.floor(10000 + Math.random() * 90000).toString(); // 5ä½æ•¸æˆ¿é–“è™Ÿ
        
        set(ref(db, 'games/' + gameId), {
            fen: game.fen(),
            turn: 'w',
            white: myUid,
            black: null,
            status: 'waiting',
            lastMove: null
        }).then(() => {
            playerColor = 'w';
            isOnline = true;
            setupGameListener();
            updateUI("waiting");
            resetCamera();
        });
    };

    window.joinRoom = function() {
        if (!myUid) return;
        let inputId = prompt("è«‹è¼¸å…¥ 5 ä½æ•¸æˆ¿é–“è™Ÿç¢¼ï¼š");
        if (!inputId) return;
        
        const gameRef = ref(db, 'games/' + inputId);
        get(gameRef).then((snapshot) => {
            if (snapshot.exists()) {
                const data = snapshot.val();
                if (data.status !== 'waiting' && data.black !== myUid) {
                    alert("æˆ¿é–“å·²æ»¿æˆ–éŠæˆ²é€²è¡Œä¸­");
                    return;
                }
                
                update(gameRef, {
                    black: myUid,
                    status: 'playing'
                });

                gameId = inputId;
                playerColor = 'b';
                isOnline = true;
                
                game.load(data.fen);
                syncPieces();
                setupGameListener();
                updateUI("playing");
                resetCamera();
            } else {
                alert("æ‰¾ä¸åˆ°æˆ¿é–“");
            }
        });
    };

    window.copyRoomId = function() {
        if(gameId) {
            navigator.clipboard.writeText(gameId);
            alert("å·²è¤‡è£½æˆ¿è™Ÿ: " + gameId);
        }
    }

    function updateUI(state) {
        const display = document.getElementById('room-display');
        const copyArea = document.getElementById('copy-area');
        const status = document.getElementById('connection-status');
        
        if (state === 'waiting') {
            display.innerText = `æˆ¿é–“è™Ÿ: ${gameId} (ç­‰å¾…å°æ‰‹)`;
            display.style.color = "#ffff00";
            copyArea.style.display = 'flex';
            status.innerText = "ç­‰å¾…ç©å®¶åŠ å…¥...";
        } else if (state === 'playing') {
            display.innerText = `æˆ¿é–“è™Ÿ: ${gameId} (å°æˆ°ä¸­)`;
            display.style.color = "#00ff00";
            copyArea.style.display = 'flex';
            status.innerText = "é€£ç·šç©©å®š";
        }
    }

    function setupGameListener() {
        const gameRef = ref(db, 'games/' + gameId);
        
        // ç›£è½éŠæˆ²è®Šå‹•
        onValue(gameRef, (snapshot) => {
            const data = snapshot.val();
            if (!data) return;

            // 1. æª¢æŸ¥æ˜¯å¦æœ‰å°æ‰‹åŠ å…¥
            if (playerColor === 'w' && data.black && data.status === 'playing') {
                updateUI("playing");
            }

            // 2. åŒæ­¥æ£‹ç›¤ç‹€æ…‹
            if (data.fen !== game.fen()) {
                game.load(data.fen);
                // åŸ·è¡Œå‹•ç•«æˆ–å¼·åˆ¶åŒæ­¥
                if (data.lastMove) {
                     // ç°¡å–®è™•ç†ï¼šç›´æ¥é‡ç¹ªæ‰€æœ‰æ£‹å­ï¼Œç¢ºä¿çµ•å°åŒæ­¥
                     syncPieces(); 
                } else {
                    syncPieces();
                }
            }

            // 3. æ›´æ–°å›åˆé¡¯ç¤º
            const turn = game.turn();
            const turnTxt = document.getElementById('turn-txt');
            if (turn === 'w') {
                turnTxt.innerText = "ç™½æ–¹å›åˆ";
                turnTxt.style.color = "#00e5ff";
            } else {
                turnTxt.innerText = "é»‘æ–¹å›åˆ";
                turnTxt.style.color = "#ff0055";
            }

            // 4. åˆ¤æ–·å‹è² 
            if (data.winner) {
                turnTxt.innerText = data.winner === 'w' ? "ç™½æ–¹ç²å‹!" : "é»‘æ–¹ç²å‹!";
                turnTxt.style.color = "#ffff00";
                setTimeout(() => alert(data.winner === 'w' ? "ç™½æ–¹ç²å‹!" : "é»‘æ–¹ç²å‹!"), 100);
            }
        });
        
        // æ–·ç·šè™•ç†ï¼šå¦‚æœæˆ‘æ–·ç·šäº†ï¼Œå˜—è©¦æ¨™è¨˜éŠæˆ²
        onDisconnect(gameRef).update({
            status: 'interrupted'
        });
    }

    function sendMove(move) {
        if (!isOnline || !gameId) return;
        
        let updateData = {
            fen: game.fen(),
            turn: game.turn(),
            lastMove: move
        };

        if (game.in_checkmate()) {
            updateData.winner = game.turn() === 'w' ? 'b' : 'w'; // è¢«å°‡æ­»çš„äººè¼¸äº†ï¼Œæ‰€ä»¥è´å®¶æ˜¯å°å®¶
            updateData.status = 'finished';
        }

        update(ref(db, 'games/' + gameId), updateData);
    }

    // ==========================================
    // ğŸ¨ 3D å ´æ™¯èˆ‡æ¸²æŸ“ (Three.js)
    // ==========================================

    function init3D() {
        const clock = new THREE.Clock();
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x111111, 0.002); // é»‘è‰²è¿·éœ§
        scene.background = new THREE.Color(0x050505);

        // æ”å½±æ©Ÿ
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 3000);
        camera.position.set(0, 80, 120);

        // æ¸²æŸ“å™¨
        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(CONFIG.pixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = !isMobile; // æ‰‹æ©Ÿé—œé–‰é™°å½±é‹ç®—ä»¥æå‡FPS
        if(!isMobile) renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // æ§åˆ¶å™¨
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.1;
        controls.minDistance = 20;
        controls.maxDistance = 300;
        controls.target.set(0, BOARD_HEIGHT, 0);

        // ç‡ˆå…‰
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        const dirLight = new THREE.DirectionalLight(0xffaa00, 1.5);
        dirLight.position.set(-100, 150, -100);
        if (!isMobile) {
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(1024, 1024);
        }
        scene.add(dirLight);

        // ç’°å¢ƒç”Ÿæˆ (éåŒæ­¥ä»¥å…å¡é “)
        setTimeout(() => {
            createEnvironment();
            createBoard();
            syncPieces();
        }, 50);

        // äº‹ä»¶ç›£è½
        raycaster = new THREE.Raycaster();
        window.addEventListener('resize', onWindowResize);
        
        // çµ±ä¸€è™•ç†é»æ“Šèˆ‡è§¸æ§
        const canvas = renderer.domElement;
        canvas.addEventListener('touchstart', onTouch, {passive: false});
        canvas.addEventListener('click', onClick);

        // å‹•ç•«è¿´åœˆ
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            TWEEN.update();
            controls.update();
            
            // è‰åœ°æ“ºå‹•æ•ˆæœ (åƒ…åœ¨éæ‰‹æ©Ÿæˆ–ä½è² è¼‰æ™‚é–‹å•Ÿ)
            if (grassMat && grassMat.userData.shader) {
                grassMat.userData.shader.uniforms.time.value = time;
            }
            
            renderer.render(scene, camera);
        }
        animate();
    }

    function resetCamera() {
        // æ ¹æ“šåŸ·é»‘æˆ–åŸ·ç™½æ—‹è½‰è¦–è§’
        const z = playerColor === 'w' ? 100 : -100;
        // æ ¹æ“šè¢å¹•å¯¬åº¦èª¿æ•´é è¿‘ (æ‰‹æ©Ÿè¦æ‹‰é ä¸€é»)
        const y = window.innerWidth < 600 ? 90 : 60; 
        
        new TWEEN.Tween(camera.position)
            .to({ x: 0, y: y, z: z }, 1500)
            .easing(TWEEN.Easing.Cubic.Out)
            .start();
        controls.target.set(0, BOARD_HEIGHT, 0);
    }

    // ç°¡åŒ–çš„ç’°å¢ƒç”Ÿæˆ
    function createEnvironment() {
        // åœ°é¢
        const geo = new THREE.PlaneGeometry(1000, 1000, 32, 32);
        geo.rotateX(-Math.PI / 2);
        
        // ç°¡å–®çš„èµ·ä¼
        const pos = geo.attributes.position;
        for(let i=0; i<pos.count; i++) {
            const x = pos.getX(i);
            const z = pos.getZ(i);
            const dist = Math.sqrt(x*x + z*z);
            let h = 0;
            if(dist > 50) h = Math.sin(x*0.02)*5 + Math.cos(z*0.02)*5;
            if(dist > 300) h -= 20; // é è™•ä¸‹æ²‰
            pos.setY(i, h - 15);
        }
        geo.computeVertexNormals();

        const mat = new THREE.MeshStandardMaterial({
            color: 0x112211, 
            roughness: 0.8,
            flatShading: true
        });
        const mesh = new THREE.Mesh(geo, mat);
        if(!isMobile) mesh.receiveShadow = true;
        scene.add(mesh);

        // éš¨æ©Ÿç™¼å…‰æŸ±å­ (éœ“è™¹æ°›åœ)
        const pillarGeo = new THREE.CylinderGeometry(0.5, 0.5, 20, 6);
        const pillarMat = new THREE.MeshBasicMaterial({ color: 0x00ffaa });
        for(let i=0; i<30; i++) {
            const mesh = new THREE.Mesh(pillarGeo, pillarMat);
            const r = 100 + Math.random() * 200;
            const a = Math.random() * Math.PI * 2;
            mesh.position.set(Math.cos(a)*r, 0, Math.sin(a)*r);
            scene.add(mesh);
        }

        // ç°¡å–®çš„è‰åœ° (InstancedMesh)
        if (CONFIG.grassCount > 0) {
            const bGeo = new THREE.PlaneGeometry(0.5, 2);
            bGeo.translate(0, 1, 0);
            grassMat = new THREE.MeshBasicMaterial({color: 0x226622, side: THREE.DoubleSide});
            
            // æ³¨å…¥ Shader è®“è‰å‹•èµ·ä¾†
            grassMat.onBeforeCompile = (shader) => {
                shader.uniforms.time = { value: 0 };
                shader.vertexShader = `uniform float time;\n` + shader.vertexShader;
                shader.vertexShader = shader.vertexShader.replace(
                    `#include <begin_vertex>`,
                    `vec3 transformed = vec3( position );
                     float wave = sin(time * 2.0 + position.x * 0.5) * 0.3 * position.y;
                     transformed.x += wave;
                     #include <begin_vertex>`
                );
                grassMat.userData.shader = shader;
            };

            const iMesh = new THREE.InstancedMesh(bGeo, grassMat, CONFIG.grassCount);
            const dummy = new THREE.Object3D();
            let count = 0;
            for(let i=0; i<CONFIG.grassCount; i++) {
                const r = 40 + Math.random() * 150;
                const a = Math.random() * Math.PI * 2;
                dummy.position.set(Math.cos(a)*r, -15, Math.sin(a)*r);
                dummy.rotation.y = Math.random() * Math.PI;
                dummy.updateMatrix();
                iMesh.setMatrixAt(count++, dummy.matrix);
            }
            scene.add(iMesh);
        }
    }

    function createBoard() {
        // æ£‹ç›¤åº•åº§
        const base = new THREE.Mesh(
            new THREE.BoxGeometry(9, 1, 9),
            new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.2})
        );
        base.position.y = BOARD_HEIGHT - 0.5;
        scene.add(base);

        // é‚Šæ¡†å…‰åœˆ
        const ring = new THREE.Mesh(
            new THREE.TorusGeometry(8, 0.2, 8, 32),
            new THREE.MeshBasicMaterial({color: 0x00e5ff})
        );
        ring.rotation.x = Math.PI/2;
        ring.position.y = BOARD_HEIGHT - 0.5;
        scene.add(ring);

        // æ ¼å­
        for(let r=0; r<8; r++) {
            for(let c=0; c<8; c++) {
                const isWhite = (r+c)%2 !== 0;
                const tile = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 0.2, 1),
                    new THREE.MeshStandardMaterial({
                        color: isWhite ? 0xccddff : 0x222233,
                        roughness: 0.5
                    })
                );
                tile.position.set(c-3.5, BOARD_HEIGHT, 3.5-r);
                
                const sqName = String.fromCharCode(97+c) + (r+1);
                tile.userData = { square: sqName, isTile: true };
                
                if(!isMobile) tile.receiveShadow = true;
                scene.add(tile);
                tilesMap[sqName] = tile;
            }
        }
    }

    function createPiece(type, color) {
        const group = new THREE.Group();
        // ç°¡åŒ–æè³ªä»¥æå‡æ•ˆèƒ½
        const mat = new THREE.MeshStandardMaterial({
            color: color === 'w' ? 0xffffff : 0x333333,
            roughness: 0.3,
            metalness: 0.2
        });
        const glowColor = color === 'w' ? 0x00e5ff : 0xff0055;
        const glowMat = new THREE.MeshBasicMaterial({ color: glowColor });

        // é€šç”¨åº•åº§
        const base = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 0.2, 16), mat);
        group.add(base);

        let body;
        // æ ¹æ“šæ£‹å­é¡å‹å»ºç«‹ç°¡å–®å¹¾ä½•é«”
        switch(type) {
            case 'p': // å…µ
                body = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.8, 16), mat);
                body.position.y = 0.5;
                break;
            case 'r': // è»Š
                body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.8, 0.5), mat);
                body.position.y = 0.5;
                break;
            case 'n': // é¦¬ (ç”¨åˆ‡è§’çš„Boxä»£æ›¿)
                body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.8, 0.3), mat);
                body.position.y = 0.5;
                body.rotation.x = Math.PI/4; // å‚¾æ–œ
                break;
            case 'b': // è±¡
                body = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.3, 1.0, 16), mat);
                body.position.y = 0.6;
                break;
            case 'q': // å
                body = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 1.4, 16), mat);
                body.position.y = 0.8;
                // åå† å…‰ç’°
                const crown = new THREE.Mesh(new THREE.TorusGeometry(0.2, 0.05, 8, 16), glowMat);
                crown.rotation.x = Math.PI/2;
                crown.position.y = 1.5;
                group.add(crown);
                break;
            case 'k': // ç‹
                body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, 1.6, 16), mat);
                body.position.y = 0.9;
                const cross = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), glowMat);
                cross.position.y = 1.8;
                group.add(cross);
                break;
        }
        if(body) {
            if(!isMobile) body.castShadow = true;
            group.add(body);
        }

        return group;
    }

    function syncPieces() {
        // æ¸…é™¤èˆŠæ£‹å­
        for (let sq in piecesMap) {
            scene.remove(piecesMap[sq]);
        }
        piecesMap = {};

        const board = game.board();
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const p = board[r][c];
                if (p) {
                    const mesh = createPiece(p.type, p.color);
                    mesh.position.set(c - 3.5, BOARD_HEIGHT + 0.1, 3.5 - r); // r å°æ‡‰ z (åå‘)
                    // ä¿®æ­£ï¼šæ£‹ç›¤åº§æ¨™ 0,0 æ˜¯ a8ï¼Œä½†åœ¨ 3D ä¸­ z è»¸æ˜¯åçš„
                    // Chess.js: row 0 is rank 8. 
                    // 3D: z -3.5 is top.
                    // ä¿®æ­£åº§æ¨™å°æ‡‰ï¼š
                    // row 0 (rank 8) -> z = -3.5
                    // row 7 (rank 1) -> z = 3.5
                    mesh.position.z = (r - 3.5); 
                    
                    scene.add(mesh);
                    const sqName = String.fromCharCode(97 + c) + (8 - r);
                    piecesMap[sqName] = mesh;
                }
            }
        }
    }

    // ==========================================
    // ğŸ® äº’å‹•æ§åˆ¶
    // ==========================================

    function onTouch(e) {
        if (e.touches.length > 1) return; // é›™æŒ‡ç¸®æ”¾äº¤çµ¦ OrbitControls
        e.preventDefault(); // é˜²æ­¢æ»¾å‹•
        
        // è½‰æ›è§¸æ§åº§æ¨™
        const touch = e.touches[0];
        const mouse = new THREE.Vector2();
        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        
        handleInput(mouse);
    }

    function onClick(e) {
        const mouse = new THREE.Vector2();
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        handleInput(mouse);
    }

    function handleInput(mouse) {
        // 1. æª¢æŸ¥æ˜¯å¦è¼ªåˆ°è‡ªå·±
        if (isOnline && game.turn() !== playerColor) return;
        if (isProcessing) return;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(Object.values(tilesMap));

        if (intersects.length > 0) {
            const sq = intersects[0].object.userData.square;
            onSquareClick(sq);
        }
    }

    function onSquareClick(sq) {
        const piece = game.get(sq);

        // æƒ…æ³ A: é¸ä¸­è‡ªå·±çš„æ£‹å­
        if (piece && piece.color === playerColor) { // å¼·åˆ¶åªèƒ½é¸è‡ªå·±çš„é¡è‰²
            highlightSquare(sq);
            selectedSquare = sq;
            return;
        }

        // æƒ…æ³ B: å·²ç¶“é¸äº†æ£‹å­ï¼Œç¾åœ¨é»æ“Šç›®æ¨™æ ¼ (ç§»å‹•æˆ–åƒå­)
        if (selectedSquare) {
            const move = game.move({
                from: selectedSquare,
                to: sq,
                promotion: 'q' // ç°¡åŒ–ï¼šä¸€å¾‹å‡è®Šçš‡å
            });

            if (move) {
                // ç§»å‹•æˆåŠŸ
                animateMove(move);
                sendMove(move); // ç™¼é€çµ¦ä¼ºæœå™¨
            } else {
                // ç§»å‹•ä¸åˆæ³•ï¼Œå–æ¶ˆé¸å–
                clearHighlight();
                selectedSquare = null;
            }
        }
    }

    function highlightSquare(sq) {
        clearHighlight();
        // é«˜äº®é¸ä¸­çš„æ ¼å­
        if(tilesMap[sq]) {
            tilesMap[sq].material.emissive.setHex(0xffff00);
            tilesMap[sq].material.emissiveIntensity = 0.5;
        }
        // é«˜äº®å¯ç§»å‹•çš„æ ¼å­
        const moves = game.moves({ square: sq, verbose: true });
        moves.forEach(m => {
            if(tilesMap[m.to]) {
                const color = m.captured ? 0xff0000 : 0x00ff00; // åƒå­é¡¯ç´…ï¼Œç§»å‹•é¡¯ç¶ 
                tilesMap[m.to].material.emissive.setHex(color);
                tilesMap[m.to].material.emissiveIntensity = 0.3;
            }
        });
    }

    function clearHighlight() {
        for(let s in tilesMap) {
            tilesMap[s].material.emissive.setHex(0x000000);
            tilesMap[s].material.emissiveIntensity = 0;
        }
    }

    function animateMove(move) {
        isProcessing = true;
        clearHighlight();
        selectedSquare = null;

        const startMesh = piecesMap[move.from];
        const endPos = tilesMap[move.to].position.clone();
        endPos.y += 0.1; // ä¿®æ­£é«˜åº¦

        // å¦‚æœæœ‰åƒå­ï¼Œå…ˆç§»é™¤è¢«åƒæ‰çš„æ£‹å­
        if (move.captured && piecesMap[move.to]) {
            scene.remove(piecesMap[move.to]);
            delete piecesMap[move.to];
        }

        // ç§»å‹•å‹•ç•«
        new TWEEN.Tween(startMesh.position)
            .to(endPos, 300)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onComplete(() => {
                // å‹•ç•«çµæŸå¾Œï¼Œé‡æ–°åŒæ­¥æœ€æº–ç¢ºçš„ç‹€æ…‹
                syncPieces();
                isProcessing = false;
                
                // æª¢æŸ¥å°‡æ­» (æœ¬åœ°é¡¯ç¤º)
                if(game.in_checkmate()) alert("Checkmate!");
            })
            .start();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // å•Ÿå‹•
    autoLogin();
    init3D();

</script>
</body>
</html>
