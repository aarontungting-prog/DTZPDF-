<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>霓虹西洋棋：終極無瑕版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/objects/Sky.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Microsoft JhengHei', sans-serif; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        .panel { position: absolute; background: rgba(0,0,0,0.7); color: #fff; padding: 15px; border-radius: 12px; pointer-events: auto; backdrop-filter: blur(8px); border: 1px solid #00e5ff; }
        #status { top: 20px; right: 20px; text-align: right; width: 220px; }
        #log { bottom: 20px; left: 20px; width: 280px; max-height: 120px; overflow-y: auto; font-size: 13px; border-left: 4px solid #00e5ff; }
    </style>
</head>
<body>

<div id="ui">
    <div id="status" class="panel">
        <div style="color: #00e5ff; font-size: 0.9em; letter-spacing: 1px;">SYSTEM STATUS</div>
        <div id="turn-txt" style="font-size: 22px; font-weight: bold;">白方 (玩家)</div>
        <div id="check-alert" style="color:#ff4444; display:none; font-weight:bold; animation: blink 1s infinite;">⚠️ 領主受威脅</div>
    </div>
    <div id="log" class="panel">
        <div id="move-log">同步 Slow Roads 環境數據...</div>
    </div>
</div>

<script>
let scene, camera, renderer, controls, raycaster, mouse, clock;
let game = new Chess(), tiles = [], pieceObjects = {};
let selectedSquare = null, isProcessing = false;
let grassMat, cloudTex;

const CHESS_NAMES = { k: '國王', q: '皇后', r: '城堡', b: '主教', n: '騎士', p: '兵卒' };
const NEON_COLORS = { w: '#00e5ff', b: '#bd00ff' };

function init() {
    clock = new THREE.Clock();
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x87ceeb, 20, 60);

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 12, 16);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 2.1;

    setupSlowRoadsEnvironment();
    createBoard();
    syncInitialPieces();

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    window.addEventListener('click', onInteract);
    animate();
}

/**
 * 1. 修正版交互邏輯：嚴格鎖定白方，解決「點紫色變藍色」問題
 */
function onInteract(e) {
    if(isProcessing || game.turn() === 'b' || game.game_over()) return;

    mouse.x = (e.clientX/window.innerWidth)*2-1;
    mouse.y = -(e.clientY/window.innerHeight)*2+1;
    raycaster.setFromCamera(mouse, camera);

    const hits = raycaster.intersectObjects(tiles);
    if(hits.length === 0) return;

    const square = hits[0].object.userData.square;
    const piece = game.get(square);

    if (!selectedSquare) {
        // 第一步：選取 (必須是玩家自己的白方棋子)
        if (piece && piece.color === 'w') {
            selectedSquare = square;
            highlightMoves(game.moves({ square, verbose: true }));
        }
    } else {
        // 第二步：點擊另一個自己的棋子 -> 更換選取 (Bug 修正)
        if (piece && piece.color === 'w') {
            selectedSquare = square;
            highlightMoves(game.moves({ square, verbose: true }));
            return;
        }

        // 嘗試執行移動
        const move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
        
        if (move) {
            isProcessing = true; // 鎖定直到動畫與 AI 完成
            executeMoveAnimation(move);
        } else {
            // 非法移動：不要重置選取，讓玩家可以重新選目標 (Bug 修正)
            logAction("非法路徑：請重新選擇目標位置", "#ff4444");
        }
    }
}

/**
 * 2. 修正版動畫核心：解決「斜線跨格」與「對象混亂」
 */
function executeMoveAnimation(move) {
    const sprite = pieceObjects[move.from];
    if (!sprite) return;

    // 處理吃子：如果是吃子，將目標格子的紫色棋子移除
    if (move.captured) {
        const victim = pieceObjects[move.to];
        if (victim) {
            new TWEEN.Tween(victim.material).to({ opacity: 0 }, 200).onComplete(() => {
                scene.remove(victim);
            }).start();
            delete pieceObjects[move.to];
        }
    }

    const tx = (move.to.charCodeAt(0) - 97) - 3.5;
    const tz = (parseInt(move.to[1]) - 1) - 3.5;

    // 移動動畫
    new TWEEN.Tween(sprite.position)
        .to({ x: tx, z: tz }, 600)
        .easing(TWEEN.Easing.Quadratic.Out)
        .onComplete(() => {
            // 更新地圖映射
            pieceObjects[move.to] = sprite;
            delete pieceObjects[move.from];
            
            // 處理升變
            if (move.promotion) {
                sprite.material.map = createPieceTexture(move.promotion, move.color);
            }

            updateHUD();
            logAction(`玩家移動：${CHESS_NAMES[move.piece]} 到 ${move.to}`);

            if(!game.game_over()) {
                if (game.turn() === 'b') setTimeout(makeAI, 800);
                else isProcessing = false;
            } else { isProcessing = false; logAction("GAME OVER!", "#ffd700"); }
        })
        .start();

    resetHighlights();
    selectedSquare = null;
}

/**
 * 3. 修正版高亮：區分顏色與類型
 */
function highlightMoves(moves) {
    resetHighlights();
    const selTile = tiles.find(t => t.userData.square === selectedSquare);
    if(selTile) {
        selTile.material.emissive.set(0xffff00); // 選中格為黃色
        selTile.material.emissiveIntensity = 0.5;
    }

    moves.forEach(m => {
        const t = tiles.find(tile => tile.userData.square === m.to);
        if(t) {
            // 吃子格紅色，移動格青色
            t.material.emissive.set(m.captured ? 0xff4444 : 0x00e5ff);
            t.material.emissiveIntensity = 0.8;
        }
    });
}

function resetHighlights() {
    tiles.forEach(t => {
        const isW = (t.userData.baseColor.getHex() === 0xffffff);
        t.material.emissive.set(isW ? 0x111111 : 0x000033);
        t.material.emissiveIntensity = 0.2;
    });
}

/**
 * 4. 修正版動畫循環：解決「AI棋子亂跳」
 */
function animate() {
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();
    TWEEN.update();
    controls.update();
    
    // 更新草地與雲朵
    if(grassMat && grassMat.userData.shader) grassMat.userData.shader.uniforms.time.value = time;
    if(cloudTex) { cloudTex.offset.x += 0.0015; cloudTex.offset.y += 0.0008; }

    // 呼吸動畫優化：只對白方棋子套用 (Bug 修正)
    Object.keys(pieceObjects).forEach(sq => {
        const p = pieceObjects[sq];
        const pieceData = game.get(sq);
        if (pieceData && pieceData.color === 'w') {
            // 只有白方棋子有呼吸感，且 y 軸鎖定在正確高度
            p.position.y = 0.7 + Math.sin(time * 2.5 + sq.charCodeAt(0)) * 0.05;
        } else {
            // 紫方棋子靜止不動
            p.position.y = 0.7;
        }
    });

    renderer.render(scene, camera);
}

// --- 環境、貼圖、HUD 生成函數 (省略重複代碼但功能齊全) ---
function setupSlowRoadsEnvironment() {
    const sky = new THREE.Sky(); sky.scale.setScalar(500); scene.add(sky);
    const sun = new THREE.Vector3(); sun.setFromSphericalCoords(1, THREE.MathUtils.degToRad(86), THREE.MathUtils.degToRad(180));
    sky.material.uniforms['sunPosition'].value.copy(sun);

    const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x2d5a27 }));
    ground.rotation.x = -Math.PI / 2; ground.position.y = -0.15; ground.receiveShadow = true; scene.add(ground);

    const grassGeo = new THREE.PlaneGeometry(0.15, 0.45); grassGeo.translate(0, 0.22, 0);
    grassMat = new THREE.MeshStandardMaterial({ color: 0x3d7a3a, side: THREE.DoubleSide });
    grassMat.onBeforeCompile = (sh) => {
        sh.uniforms.time = { value: 0 };
        sh.vertexShader = `uniform float time;\n` + sh.vertexShader;
        sh.vertexShader = sh.vertexShader.replace(`#include <begin_vertex>`, `vec3 transformed = vec3(position); transformed.x += sin(time * 1.8 + position.x * 2.5) * 0.07 * position.y; #include <begin_vertex>`);
        grassMat.userData.shader = sh;
    };
    const instGrass = new THREE.InstancedMesh(grassGeo, grassMat, 3500);
    const d = new THREE.Object3D();
    for(let i=0; i<3500; i++) {
        const x = Math.random()*50-25, z = Math.random()*50-25;
        if(Math.abs(x)<4.5 && Math.abs(z)<4.5) continue;
        d.position.set(x, -0.1, z); d.rotation.y = Math.random()*Math.PI; d.updateMatrix();
        instGrass.setMatrixAt(i, d.matrix);
    }
    scene.add(instGrass);
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const l = new THREE.DirectionalLight(0xffffff, 1.0); l.position.set(10, 20, 10); l.castShadow = true; scene.add(l);
    
    const cloudGeo = new THREE.SphereGeometry(98, 32, 32);
    cloudTex = new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/earth_clouds_2048.png');
    cloudTex.wrapS = cloudTex.wrapT = THREE.RepeatWrapping;
    scene.add(new THREE.Mesh(cloudGeo, new THREE.MeshBasicMaterial({ map: cloudTex, transparent: true, opacity: 0.35, side: THREE.BackSide })));
}

function createBoard() {
    for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
            const isW = (r+c)%2===1;
            const t = new THREE.Mesh(new THREE.BoxGeometry(0.98, 0.2, 0.98), new THREE.MeshStandardMaterial({ color: isW?0xffffff:0x222222 }));
            t.position.set(c-3.5, 0, 7-r-3.5);
            t.userData = { square: String.fromCharCode(97+c)+(r+1), baseColor: t.material.color.clone(), isTile: true };
            t.receiveShadow = true; scene.add(t); tiles.push(t);
        }
    }
}

function syncInitialPieces() {
    game.board().forEach((row, rIdx) => {
        row.forEach((cell, cIdx) => {
            if(cell) {
                const sq = String.fromCharCode(97+cIdx)+(8-rIdx);
                const mat = new THREE.SpriteMaterial({ map: createPieceTexture(cell.type, cell.color), transparent: true });
                const s = new THREE.Sprite(mat); s.scale.set(0.8, 1.2, 1);
                s.position.set(cIdx-3.5, 0.7, (8-rIdx)-1-3.5); s.castShadow = true;
                scene.add(s); pieceObjects[sq] = s;
            }
        });
    });
}

function createPieceTexture(t, c) {
    const canv = document.createElement('canvas'); canv.width = 256; canv.height = 384;
    const ctx = canv.getContext('2d');
    const g = ctx.createLinearGradient(0,0,0,384);
    g.addColorStop(0, '#000'); g.addColorStop(1, c==='w'?'#001a33':'#1a0033');
    ctx.fillStyle = g; ctx.fillRect(0,0,256,384);
    ctx.strokeStyle = NEON_COLORS[c]; ctx.lineWidth = 15; ctx.strokeRect(10,10,236,364);
    ctx.fillStyle = 'white'; ctx.textAlign='center'; ctx.font='160px serif';
    ctx.fillText({k:'♔',q:'♕',r:'♖',b:'♗',n:'♘',p:'♙'}[t], 128, 200);
    ctx.font='bold 45px sans-serif'; ctx.fillText(CHESS_NAMES[t], 128, 300);
    return new THREE.CanvasTexture(canv);
}

function makeAI() {
    const ms = game.moves();
    let b = ms[Math.floor(Math.random()*ms.length)];
    for(let m of ms) if(m.includes('x')) b = m;
    const info = game.move(b);
    executeMoveAnimation(info);
    isProcessing = false;
}

function logAction(txt, color="#00e5ff") {
    const log = document.getElementById('move-log');
    log.innerHTML += `<br><span style="color:${color}">• ${txt}</span>`;
    log.scrollTop = log.scrollHeight;
}

function updateHUD() {
    document.getElementById('turn-txt').innerText = game.turn()==='w'?"白方 (玩家)":"黑方 (電腦)";
    document.getElementById('check-alert').style.display = game.in_check()?'block':'none';
}

init();
</script>
</body>
</html>
