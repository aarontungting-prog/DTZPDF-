<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二次元西洋棋：覺醒之戰</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle, #2c3e50, #000); font-family: 'PingFang TC', sans-serif; color: #fff; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .panel { position: absolute; background: rgba(0,0,0,0.85); border: 1px solid #00f2ff; padding: 20px; border-radius: 12px; pointer-events: auto; }
        #draw-panel { top: 20px; left: 20px; width: 280px; box-shadow: 0 0 20px #00f2ff66; }
        #status-panel { top: 20px; right: 20px; text-align: right; border-color: #ff00ff; }
        .btn { background: #00f2ff; color: #000; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; width: 100%; margin-top: 10px; }
        .btn:disabled { background: #555; cursor: not-allowed; }
        #gacha-pool { margin: 15px 0; max-height: 300px; overflow-y: auto; font-size: 14px; }
        .rarity-SSR { color: #ffae00; text-shadow: 0 0 5px #ffae00; }
        #dialog { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #111; border: 2px solid #fff; padding: 30px; border-radius: 15px; display: none; text-align: center; z-index: 100; pointer-events: auto; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="draw-panel" class="panel">
        <h2 style="margin:0">召喚祭壇</h2>
        <div id="gacha-pool">等待召喚英雄...</div>
        <button id="draw-btn" class="btn">進行召喚 (已抽: <span id="draw-count">0</span>/16)</button>
        <button id="start-btn" class="btn" style="background:#ff00ff; display:none;">進入戰場</button>
    </div>
    <div id="status-panel" class="panel">
        <div>當前回合: <span id="turn-text" style="color:#00f2ff">白方 (你)</span></div>
        <div id="skill-text" style="font-size:12px; color:#aaa; margin-top:5px;"></div>
    </div>
    <div id="dialog">
        <h2 id="msg-title"></h2>
        <p id="msg-body"></p>
        <button class="btn" onclick="document.getElementById('dialog').style.display='none'">確定</button>
    </div>
</div>

<script>
// --- 核心變數 ---
let scene, camera, renderer, raycaster, mouse;
let pieces = [], boardTiles = [];
let playerDrawn = [];
let selectedPiece = null;
let currentTurn = 'white';
let gameState = 'drawing'; // drawing, playing

// 角色預設數據
const CHARS = [
    { type: 'king', rarity: 'SSR', name: '聖光騎士王', img: 'https://i.imgur.com/vHqB8pL.png' },
    { type: 'queen', rarity: 'SSR', name: '冰霜女皇', img: 'https://i.imgur.com/rL7tK1n.png' },
    { type: 'rook', rarity: 'SR', name: '鋼鐵重裝', img: 'https://i.imgur.com/7YV8b1h.png' },
    { type: 'knight', rarity: 'SR', name: '疾風赤兔', img: 'https://i.imgur.com/3p0X5W9.png' },
    { type: 'bishop', rarity: 'SR', name: '星辰大祭司', img: 'https://i.imgur.com/z8pGf0W.png' },
    { type: 'pawn', rarity: 'R', name: '見習劍士', img: 'https://i.imgur.com/8pS6X9v.png' }
];

// --- 初始化 ---
function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 8, 8);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
    scene.add(light);

    // 建立棋盤
    for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
            const geo = new THREE.BoxGeometry(0.95, 0.1, 0.95);
            const mat = new THREE.MeshPhongMaterial({ color: (r+c)%2===0 ? 0x333333 : 0x111111 });
            const tile = new THREE.Mesh(geo, mat);
            tile.position.set(c-3.5, 0, r-3.5);
            tile.userData = { row: r, col: c, isTile: true, originalColor: mat.color.clone() };
            scene.add(tile);
            boardTiles.push(tile);
        }
    }

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    window.addEventListener('click', onClick);
    animate();
}

// --- 抽卡邏輯 ---
document.getElementById('draw-btn').onclick = () => {
    if(playerDrawn.length >= 16) return;
    
    const rand = Math.random();
    let template = CHARS[Math.floor(Math.random() * CHARS.length)];
    const color = playerDrawn.length < 8 ? 'white' : 'black';
    
    const newChar = { ...template, color, id: Date.now() + Math.random() };
    playerDrawn.push(newChar);
    
    updateGachaUI();
    if(playerDrawn.length === 16) {
        document.getElementById('draw-btn').disabled = true;
        document.getElementById('start-btn').style.display = 'block';
    }
};

function updateGachaUI() {
    const pool = document.getElementById('gacha-pool');
    pool.innerHTML = playerDrawn.map(c => `<div class="rarity-${c.rarity}">[${c.rarity}] ${c.name} (${c.color==='white'?'白':'黑'})</div>`).join('');
    document.getElementById('draw-count').innerText = playerDrawn.length;
}

// --- 遊戲開始與佈陣 ---
document.getElementById('start-btn').onclick = () => {
    gameState = 'playing';
    document.getElementById('draw-panel').style.display = 'none';
    
    // 自動佈陣：白方 0,1 排；黑方 6,7 排
    playerDrawn.forEach((char, i) => {
        const row = char.color === 'white' ? Math.floor(i/8) : 7 - Math.floor((i-8)/8);
        const col = i % 8;
        createPiece(char, row, col);
    });
};

function createPiece(char, row, col) {
    const canvas = document.createElement('canvas'); // 用來畫名字和顏色標記
    const tex = new THREE.TextureLoader().load(char.img);
    const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
    const geo = new THREE.PlaneGeometry(0.8, 1.2);
    const mesh = new THREE.Mesh(geo, mat);
    
    mesh.userData = { char, row, col, isPiece: true };
    updatePiecePos(mesh);
    scene.add(mesh);
    pieces.push(mesh);
}

function updatePiecePos(mesh) {
    mesh.position.set(mesh.userData.col - 3.5, 0.7, mesh.userData.row - 3.5);
}

// --- 核心點擊與移動 ---
function onClick(e) {
    if(gameState !== 'playing') return;
    if(currentTurn === 'black') return; // AI 回合不能點

    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    
    const intersects = raycaster.intersectObjects(scene.children);
    if(intersects.length > 0) {
        const obj = intersects[0].object;
        
        if(obj.userData.isPiece && obj.userData.char.color === 'white') {
            selectedPiece = obj;
            highlightTiles(getValidMoves(obj));
        } else if(selectedPiece && (obj.userData.isTile || obj.userData.isPiece)) {
            const target = obj.userData;
            const moves = getValidMoves(selectedPiece);
            if(moves.some(m => m.r === target.row && m.c === target.col)) {
                executeMove(selectedPiece, target.row, target.col);
            }
        }
    }
}

function getValidMoves(piece) {
    const { row, col, char } = piece.userData;
    let moves = [];
    const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
    
    // 這裡實作簡化版西洋棋規則 + SSR 技能
    const range = (char.type === 'king' || char.type === 'pawn') ? 1 : 8;
    
    dirs.forEach(d => {
        for(let i=1; i<=range; i++) {
            const nr = row + d[0]*i, nc = col + d[1]*i;
            if(nr<0||nr>7||nc<0||nc>7) break;
            const target = pieces.find(p => p.userData.row === nr && p.userData.col === nc);
            if(!target) {
                moves.push({r: nr, c: nc});
            } else {
                if(target.userData.char.color !== char.color) moves.push({r: nr, c: nc});
                break;
            }
        }
    });
    return moves;
}

function executeMove(piece, r, c) {
    const target = pieces.find(p => p.userData.row === r && p.userData.col === c);
    if(target) {
        scene.remove(target);
        pieces = pieces.filter(p => p !== target);
        if(target.userData.char.type === 'king') endGame(piece.userData.char.color);
    }
    
    piece.userData.row = r;
    piece.userData.col = c;
    updatePiecePos(piece);
    resetTiles();
    
    currentTurn = currentTurn === 'white' ? 'black' : 'white';
    updateUI();
    if(currentTurn === 'black') setTimeout(blackAI, 1000);
}

function blackAI() {
    const blackPieces = pieces.filter(p => p.userData.char.color === 'black');
    // 找一個有步可走的棋子
    for(let p of blackPieces) {
        const moves = getValidMoves(p);
        if(moves.length > 0) {
            const move = moves[Math.floor(Math.random()*moves.length)];
            executeMove(p, move.r, move.c);
            return;
        }
    }
    currentTurn = 'white'; // 若無步可走則換人
    updateUI();
}

// --- 視覺優化 ---
function highlightTiles(moves) {
    resetTiles();
    moves.forEach(m => {
        const tile = boardTiles.find(t => t.userData.row === m.r && t.userData.col === m.c);
        if(tile) tile.material.color.set(0x00f2ff);
    });
}

function resetTiles() {
    boardTiles.forEach(t => t.material.color.copy(t.userData.originalColor));
}

function animate() {
    requestAnimationFrame(animate);
    // 浮空動畫
    pieces.forEach(p => {
        p.position.y = 0.7 + Math.sin(Date.now() * 0.003 + p.userData.row * 100) * 0.1;
        p.rotation.y = Math.sin(Date.now() * 0.001) * 0.1; // 輕微晃動
    });
    renderer.render(scene, camera);
}

function updateUI() {
    const t = document.getElementById('turn-text');
    t.innerText = currentTurn === 'white' ? '白方 (你)' : '黑方 (AI)';
    t.style.color = currentTurn === 'white' ? '#00f2ff' : '#ff00ff';
}

function endGame(winner) {
    const d = document.getElementById('dialog');
    document.getElementById('msg-title').innerText = winner === 'white' ? '勝利！' : '失敗';
    document.getElementById('msg-body').innerText = winner === 'white' ? '你成功守護了次元的平衡。' : '世界陷入了永恆的混沌...';
    d.style.display = 'block';
    gameState = 'over';
}

init();
</script>
</body>
</html>
