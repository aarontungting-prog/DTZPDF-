<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>æ•¸å­¸å¯¦é©—å®¤ Pro Plus (ç©åˆ†èˆ‡ç­‰æ¯”ä¾‹è¦–åœ–)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; margin: 0; display: flex; height: 100vh; background: #f4f6f8; overflow: hidden; }
        
        /* å·¦å´æ§åˆ¶é¢æ¿ */
        .sidebar { width: 380px; background: white; border-right: 1px solid #dcdcdc; display: flex; flex-direction: column; z-index: 20; box-shadow: 4px 0 20px rgba(0,0,0,0.05); }
        .header { padding: 20px; background: #2c3e50; color: white; }
        .header h2 { margin: 0; font-size: 1.3rem; letter-spacing: 1px; }
        .header p { margin: 5px 0 0; font-size: 0.85rem; color: #bdc3c7; }
        
        .controls-area { padding: 15px; background: #ecf0f1; border-bottom: 1px solid #ddd; font-size: 0.9rem; }
        .control-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .toggle-label { cursor: pointer; display: flex; align-items: center; gap: 8px; color: #2c3e50; font-weight: 600; }

        /* ç©åˆ†è¨ˆç®—å€ */
        .integral-panel { background: #fff3cd; padding: 10px; margin-bottom: 10px; border-radius: 6px; border: 1px solid #ffeeba; display: none; }
        .integral-inputs { display: flex; gap: 5px; align-items: center; margin-top: 5px; }
        .integral-result { font-weight: bold; color: #856404; margin-left: 10px; }

        .scroll-area { flex-grow: 1; overflow-y: auto; padding: 15px; }
        
        /* æ–¹ç¨‹å¼å¡ç‰‡ */
        .input-card { background: white; border: 1px solid #e0e0e0; padding: 15px; margin-bottom: 12px; border-radius: 8px; border-left: 5px solid #3498db; position: relative; transition: all 0.2s; }
        .input-card:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.1); transform: translateY(-2px); }
        
        /* ç•¶å‰é¸ä¸­è¨ˆç®—ç©åˆ†çš„å¡ç‰‡ */
        .input-card.active-integral { border-left-color: #f1c40f; background: #fffdf9; border: 2px solid #f1c40f; }

        .card-header { display: flex; justify-content: space-between; margin-bottom: 10px; align-items: center; }
        .func-tag { font-size: 12px; background: #eee; padding: 2px 6px; border-radius: 4px; color: #666; }
        
        .inputs { display: flex; flex-wrap: wrap; align-items: center; gap: 5px; font-size: 14px; }
        input[type="number"] { width: 55px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; text-align: center; font-family: monospace; }
        select { padding: 6px; border: 1px solid #ccc; border-radius: 4px; background: #fff; }

        /* æŒ‰éˆ•å„ªåŒ– */
        .footer { padding: 15px; background: white; border-top: 1px solid #eee; }
        button { width: 100%; padding: 12px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; margin-bottom: 8px; transition: 0.2s; display: flex; justify-content: center; align-items: center; gap: 5px; }
        .btn-add { background: #ebf5fb; color: #2980b9; }
        .btn-add:hover { background: #d6eaf8; }
        .btn-draw { background: #2980b9; color: white; font-size: 1.1em; }
        .btn-draw:hover { background: #2471a3; }
        .btn-reset { background: #f8f9fa; color: #7f8c8d; border: 1px solid #ddd; }

        /* åœ–è¡¨å€ï¼šæ ¸å¿ƒä¿®æ­£ - å¼·åˆ¶æ­£æ–¹å½¢æ¯”ä¾‹ */
        .main-view { flex-grow: 1; padding: 20px; background: #dcdcdc; display: flex; justify-content: center; align-items: center; position: relative; }
        
        /* é—œéµï¼šä½¿ç”¨ aspect-ratio: 1 / 1 å¼·åˆ¶æ­£æ–¹å½¢ 
           é…åˆ max-height/width ç¢ºä¿ä¸è¶…å‡ºè¢å¹•
        */
        .chart-container { 
            background: white; 
            border-radius: 4px; 
            box-shadow: 0 10px 25px rgba(0,0,0,0.2); 
            padding: 10px; 
            position: relative;
            width: auto;
            height: auto;
            aspect-ratio: 1 / 1; 
            max-height: 95vh;
            max-width: 95vh;
            display: flex; /* Fix for chartjs resize */
        }
        canvas { width: 100% !important; height: 100% !important; }
    </style>
</head>
<body>

<div class="sidebar">
    <div class="header">
        <h2>æ•¸å­¸å¯¦é©—å®¤ V2.0</h2>
        <p>å¾®ç©åˆ†é å‚™ â€¢ é¢ç©è¨ˆç®— â€¢ ç­‰æ¯”åº§æ¨™</p>
    </div>

    <div class="controls-area">
        <div class="control-row">
            <label class="toggle-label">
                <input type="checkbox" id="showIntercepts" onchange="draw()"> 
                é¡¯ç¤ºè»¸ç„¦é» (Intercepts)
            </label>
        </div>
        <div class="control-row">
            <label class="toggle-label">
                <input type="checkbox" id="showGrid" checked onchange="draw()"> 
                é¡¯ç¤ºç¶²æ ¼ (Grid)
            </label>
        </div>
        
        <div class="control-row" style="margin-top:10px; border-top:1px solid #ccc; padding-top:10px;">
            <label class="toggle-label" style="color:#d35400;">
                <input type="checkbox" id="enableIntegral" onchange="toggleIntegralMode()"> 
                é–‹å•Ÿå®šç©åˆ†æ¨¡å¼ (Area)
            </label>
        </div>
        
        <div id="integralPanel" class="integral-panel">
            <div style="font-size:12px; margin-bottom:5px;">è¨ˆç®— L<span id="targetLineNum">1</span> åœ¨ X è»¸ç¯„åœçš„é¢ç©:</div>
            <div class="integral-inputs">
                âˆ« å¾ <input type="number" id="intStart" value="0" step="0.5"> 
                åˆ° <input type="number" id="intEnd" value="2" step="0.5">
                <button onclick="calculateArea()" style="width:auto; padding:5px 10px; margin:0; background:#f1c40f; color:black;">è¨ˆç®—</button>
            </div>
            <div id="integralResult" class="integral-result"></div>
        </div>
    </div>
    
    <div class="scroll-area" id="equation-list">
        <div class="input-card" data-type="quadratic" onclick="selectForIntegral(this, 1)">
            <div class="card-header">
                <strong>L1</strong>
                <span class="func-tag">æ‹‹ç‰©ç·š</span>
                <select class="func-type" onchange="changeType(this)" style="display:none;"> <option value="quadratic" selected>Quad</option>
                </select>
            </div>
            <div class="inputs">
                y = <input type="number" class="p1" value="1">xÂ² + <input type="number" class="p2" value="0">x + <input type="number" class="p3" value="-4">
                <select class="op"><option value="=">=</option><option value=">">&gt;</option><option value="<">&lt;</option></select> y
            </div>
            <div style="margin-top:5px; text-align:right;">
                <button onclick="changeTypeUI(this)" style="width:auto; font-size:10px; padding:3px; display:inline-block; background:#eee; color:#333;">åˆ‡æ›é¡å‹</button>
            </div>
        </div>
    </div>

    <div class="footer">
        <button class="btn-add" onclick="addNewLine()">ï¼‹ æ–°å¢å‡½æ•¸</button>
        <button class="btn-draw" onclick="draw()">ğŸš€ æ›´æ–°åœ–è¡¨</button>
        <button class="btn-reset" onclick="resetZoom()">âŸ² é‡ç½®è¦–è§’ (Zoom Reset)</button>
    </div>
</div>

<div class="main-view">
    <div class="chart-container">
        <canvas id="mathChart"></canvas>
    </div>
</div>

<script>
    let myChart = null;
    let integralTargetIndex = 0; // é è¨­è¨ˆç®— L1

    // æ¨¡æ¿å®šç¾©
    const templates = {
        linear: `a: <input type="number" class="p1" value="1"> b: <input type="number" class="p2" value="-1"> c: <input type="number" class="p3" value="0"> (ax+by+c)`,
        quadratic: `y = <input type="number" class="p1" value="1">xÂ² + <input type="number" class="p2" value="0">x + <input type="number" class="p3" value="0">`,
        exp: `y = <input type="number" class="p1" value="1"> â€¢ <input type="number" class="p2" value="2">^x`,
        log: `y = <input type="number" class="p1" value="1"> â€¢ ln(<input type="number" class="p2" value="1">x)`
    };

    // åˆ‡æ›å‡½æ•¸é¡å‹ UI
    function changeTypeUI(btn) {
        const card = btn.closest('.input-card');
        const currentType = card.getAttribute('data-type');
        const types = ['linear', 'quadratic', 'exp', 'log'];
        const nextType = types[(types.indexOf(currentType) + 1) % types.length];
        
        // æ›´æ–° Data Attribute
        card.setAttribute('data-type', nextType);
        
        // æ›´æ–°æ¨™ç±¤
        const tag = card.querySelector('.func-tag');
        const map = {linear:'ç›´ç·š', quadratic:'æ‹‹ç‰©ç·š', exp:'æŒ‡æ•¸', log:'å°æ•¸'};
        tag.innerText = map[nextType];

        // æ›´æ–°è¼¸å…¥æ¡†
        const inputsDiv = card.querySelector('.inputs');
        const opHtml = `<select class="op"><option value="=">=</option><option value=">">&gt;</option><option value="<">&lt;</option></select> 0`;
        // æ³¨æ„ï¼šé™¤äº† linear æ˜¯éš±å‡½æ•¸ ax+by+c=0ï¼Œå…¶ä»–éƒ½æ˜¯ y = f(x)
        const suffix = nextType === 'linear' ? opHtml : `<select class="op"><option value="=">=</option><option value=">">&gt;</option><option value="<">&lt;</option></select> y`;
        
        inputsDiv.innerHTML = templates[nextType] + suffix.replace('0', nextType === 'linear' ? '0' : '');
    }

    function addNewLine() {
        const list = document.getElementById('equation-list');
        const n = list.children.length + 1;
        const div = document.createElement('div');
        div.className = 'input-card';
        div.setAttribute('data-type', 'linear');
        div.setAttribute('onclick', `selectForIntegral(this, ${n})`);
        div.style.borderLeftColor = `hsl(${n * 137.5}, 70%, 50%)`;
        div.innerHTML = `
            <div class="card-header">
                <strong>L${n}</strong>
                <span class="func-tag">ç›´ç·š</span>
            </div>
            <div class="inputs">
                ${templates.linear}
                <select class="op"><option value="=">=</option><option value=">">&gt;</option><option value="<">&lt;</option></select> 0
            </div>
            <div style="margin-top:5px; text-align:right;">
                <button onclick="changeTypeUI(this)" style="width:auto; font-size:10px; padding:3px; display:inline-block; background:#eee; color:#333;">åˆ‡æ›é¡å‹</button>
            </div>`;
        list.appendChild(div);
    }

    // --- ç©åˆ†é‚è¼¯ ---
    function toggleIntegralMode() {
        const panel = document.getElementById('integralPanel');
        const isOn = document.getElementById('enableIntegral').checked;
        panel.style.display = isOn ? 'block' : 'none';
        if(isOn) calculateArea(); // ç«‹å³è¨ˆç®—ä¸€æ¬¡
        draw(); // é‡ç¹ªä»¥é¡¯ç¤º/éš±è—ç©åˆ†è§£å€å¡Š
    }

    function selectForIntegral(card, index) {
        if (!document.getElementById('enableIntegral').checked) return;
        
        // UI æ›´æ–°
        document.querySelectorAll('.input-card').forEach(c => c.classList.remove('active-integral'));
        card.classList.add('active-integral');
        document.getElementById('targetLineNum').innerText = index;
        integralTargetIndex = index - 1;
        
        calculateArea();
    }

    // è¨ˆç®—ä¸å®šç©åˆ† F(x)
    function getAntiderivative(type, x, p1, p2, p3) {
        if (type === 'linear') {
            // ax + by + c = 0 => y = (-a/b)x - (c/b)
            // F(x) = (-a/2b)x^2 - (c/b)x
            if (p2 === 0) return 0; // å‚ç›´ç·šç„¡é¢ç©å®šç¾©
            return (-p1 / (2 * p2)) * x * x - (p3 / p2) * x;
        }
        if (type === 'quadratic') {
            // y = ax^2 + bx + c => F(x) = (a/3)x^3 + (b/2)x^2 + cx
            return (p1 / 3) * Math.pow(x, 3) + (p2 / 2) * Math.pow(x, 2) + p3 * x;
        }
        if (type === 'exp') {
            // y = a * b^x => F(x) = a * b^x / ln(b)
            return (p1 * Math.pow(p2, x)) / Math.log(p2);
        }
        if (type === 'log') {
            // y = a * ln(bx) => F(x) = a * (x * ln(bx) - x)
            // Note: Integral of ln(bx) dx = x*ln(bx) - x
            if (x <= 0) return 0;
            return p1 * (x * Math.log(p2 * x) - x);
        }
        return 0;
    }

    function calculateArea() {
        const cards = document.querySelectorAll('.input-card');
        if (integralTargetIndex >= cards.length) return;

        const card = cards[integralTargetIndex];
        const type = card.getAttribute('data-type');
        const p1 = parseFloat(card.querySelector('.p1').value) || 0;
        const p2 = parseFloat(card.querySelector('.p2').value) || 0;
        const p3 = parseFloat(card.querySelector('.p3')?.value) || 0;

        const start = parseFloat(document.getElementById('intStart').value);
        const end = parseFloat(document.getElementById('intEnd').value);

        if (isNaN(start) || isNaN(end)) return;

        // å¾®ç©åˆ†åŸºæœ¬å®šç†: Area = F(b) - F(a)
        const F_b = getAntiderivative(type, end, p1, p2, p3);
        const F_a = getAntiderivative(type, start, p1, p2, p3);
        const area = F_b - F_a;

        document.getElementById('integralResult').innerText = `Area â‰ˆ ${area.toFixed(4)}`;
        draw(); // é‡ç¹ªä»¥é¡¯ç¤ºé¢ç©å€åŸŸ
    }

    // --- ç¹ªåœ–æ ¸å¿ƒ ---
    function resetZoom() { if (myChart) myChart.resetZoom(); }

    function getDerivative(type, x, p1, p2, p3) {
        if (type === 'linear') return p2 !== 0 ? -p1 / p2 : Infinity;
        if (type === 'quadratic') return 2 * p1 * x + p2;
        if (type === 'exp') return p1 * Math.log(p2) * Math.pow(p2, x);
        if (type === 'log') return (Math.abs(x) < 1e-9) ? NaN : p1 / x; // Fix log(0) crash
        return 0;
    }

    function draw() {
        const cards = document.querySelectorAll('.input-card');
        const showIntercepts = document.getElementById('showIntercepts').checked;
        const showGrid = document.getElementById('showGrid').checked;
        const enableIntegral = document.getElementById('enableIntegral').checked;
        const intStart = parseFloat(document.getElementById('intStart').value);
        const intEnd = parseFloat(document.getElementById('intEnd').value);

        const datasets = [];
        const interceptsData = [];

        cards.forEach((card, i) => {
            const type = card.getAttribute('data-type');
            const p1 = parseFloat(card.querySelector('.p1').value) || 0;
            const p2 = parseFloat(card.querySelector('.p2').value) || 0;
            const p3 = parseFloat(card.querySelector('.p3')?.value) || 0;
            const op = card.querySelector('.op').value;
            const hue = (i * 137.5) % 360;
            const color = `hsl(${hue}, 70%, 50%)`;

            // 1. ç”Ÿæˆå‡½æ•¸æ›²ç·šé»
            const points = [];
            const step = (type === 'log' || type === 'exp') ? 0.05 : 0.2; 
            // ç¯„åœç¨å¾®å¤§ä¸€é»ï¼Œä¿è­‰ç¸®æ”¾é«”é©—
            for (let x = -20; x <= 20; x += step) {
                let y = null;
                if (type === 'linear') {
                    if (p2 !== 0) y = (-p1 * x - p3) / p2;
                } else if (type === 'quadratic') {
                    y = p1 * x * x + p2 * x + p3;
                } else if (type === 'exp') {
                    y = p1 * Math.pow(p2, x);
                } else if (type === 'log') {
                    if (p2 * x > 0) y = p1 * Math.log(p2 * x);
                }

                if (y !== null && !isNaN(y) && Math.abs(y) < 100) {
                    points.push({ x: x, y: y });
                }
            }
            
            // Linear Vertical Line Fix (p2=0)
            if (type === 'linear' && p2 === 0 && p1 !== 0) {
                const px = -p3 / p1;
                points.push({ x: px, y: -100 }, { x: px, y: 100 });
            }

            // 2. ä¸ç­‰å¼å¡«è‰²é‚è¼¯ä¿®æ­£ (Universal Fix)
            let fillType = false;
            if (op !== '=') {
                let isGreater = op.includes('>');
                // å¦‚æœæ˜¯ y < f(x)ï¼Œé‚£å°±æ˜¯ fill: 'start' (bottom)ï¼Œåä¹‹ 'end' (top)
                // å”¯ä¸€ä¾‹å¤–æ˜¯ linear çš„éš±å‡½æ•¸å½¢å¼ ax+by+c > 0
                if (type === 'linear') {
                    // if b < 0, dividing by b flips the sign
                    if (p2 < 0) isGreater = !isGreater;
                }
                fillType = isGreater ? 'end' : 'start';
            }

            datasets.push({
                label: `L${i+1}`,
                data: points,
                borderColor: color,
                backgroundColor: op !== '=' ? `hsla(${hue}, 70%, 50%, 0.15)` : 'transparent',
                fill: fillType,
                showLine: true,
                pointRadius: 0,
                pointHitRadius: 15,
                borderDash: (op === '>' || op === '<') ? [5, 5] : [],
                borderWidth: 2,
                customInfo: { type, p1, p2, p3 }
            });

            // 3. ç©åˆ†å€åŸŸç¹ªè£½ (Shaded Area for Integral)
            if (enableIntegral && i === integralTargetIndex) {
                const areaPoints = [];
                // åŠ ä¸Šèµ·é» (x_start, 0)
                areaPoints.push({ x: intStart, y: 0 });
                
                // åŠ ä¸Šæ›²ç·šä¸Šçš„é»
                for (let x = intStart; x <= intEnd; x += 0.1) {
                    let y = 0;
                    if (type === 'linear' && p2 !== 0) y = (-p1 * x - p3) / p2;
                    else if (type === 'quadratic') y = p1 * x * x + p2 * x + p3;
                    else if (type === 'exp') y = p1 * Math.pow(p2, x);
                    else if (type === 'log' && p2 * x > 0) y = p1 * Math.log(p2 * x);
                    
                    if (!isNaN(y)) areaPoints.push({ x: x, y: y });
                }
                
                // åŠ ä¸Šçµ‚é» (x_end, 0)
                areaPoints.push({ x: intEnd, y: 0 });

                datasets.push({
                    label: 'ç©åˆ†å€åŸŸ (Area)',
                    data: areaPoints,
                    backgroundColor: 'rgba(255, 215, 0, 0.4)', // é‡‘è‰²åŠé€æ˜
                    borderColor: 'rgba(255, 215, 0, 1)',
                    borderWidth: 1,
                    fill: 'shape', // è‡ªå®šç¾©å½¢ç‹€å¡«å……
                    showLine: true,
                    pointRadius: 0
                });
            }

            // 4. Intercepts Calculation
            if (showIntercepts) {
                // X-int (y=0)
                if (type === 'linear' && p1 !== 0) interceptsData.push({x: -p3/p1, y:0});
                if (type === 'quadratic') {
                    const D = p2*p2 - 4*p1*p3;
                    if (D >= 0) {
                        interceptsData.push({x: (-p2 + Math.sqrt(D))/(2*p1), y:0});
                        if (D>0) interceptsData.push({x: (-p2 - Math.sqrt(D))/(2*p1), y:0});
                    }
                }
                if (type === 'log' && p2 !== 0) interceptsData.push({x: 1/p2, y:0});

                // Y-int (x=0)
                if (type === 'linear' && p2 !== 0) interceptsData.push({x: 0, y: -p3/p2});
                if (type === 'quadratic') interceptsData.push({x: 0, y: p3});
                if (type === 'exp') interceptsData.push({x: 0, y: p1});
            }
        });

        if (interceptsData.length > 0) {
            datasets.push({
                label: 'ç„¦é»',
                data: interceptsData,
                backgroundColor: 'white',
                borderColor: '#333',
                borderWidth: 2,
                pointRadius: 5,
                showLine: false
            });
        }

        const ctx = document.getElementById('mathChart').getContext('2d');
        if (myChart) myChart.destroy();

        myChart = new Chart(ctx, {
            type: 'scatter',
            data: { datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false, // æˆ‘å€‘è‡ªå·±ç”¨ CSS æ§åˆ¶äº†æ¯”ä¾‹
                layout: { padding: 0 },
                scales: {
                    x: {
                        type: 'linear',
                        position: 'center',
                        min: -10, max: 10,
                        grid: { display: showGrid, color: '#e0e0e0' },
                        ticks: {
                            callback: function(val) { return val === 0 ? '' : val; } // éš±è— X è»¸çš„ 0ï¼Œé¿å…é‡ç–Š
                        }
                    },
                    y: {
                        type: 'linear',
                        position: 'center',
                        min: -10, max: 10,
                        grid: { display: showGrid, color: '#e0e0e0' },
                        ticks: {
                            callback: function(val) { return val === 0 ? '' : val; } // éš±è— Y è»¸çš„ 0
                        }
                    }
                },
                plugins: {
                    zoom: {
                        zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'xy' },
                        pan: { enabled: true } // é–‹å•Ÿå¹³ç§»ï¼Œæ–¹ä¾¿çœ‹ç©åˆ†å€åŸŸ
                    },
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (ctx) => {
                                const raw = ctx.raw;
                                if (ctx.dataset.label === 'ç©åˆ†å€åŸŸ (Area)') return `Area Region`;
                                if (ctx.dataset.label === 'ç„¦é»') return `Intercept: (${raw.x.toFixed(2)}, ${raw.y.toFixed(2)})`;
                                
                                const info = ctx.dataset.customInfo;
                                if(!info) return '';
                                const m = getDerivative(info.type, raw.x, info.p1, info.p2, info.p3);
                                return `(${raw.x.toFixed(2)}, ${raw.y.toFixed(2)}) m â‰ˆ ${isNaN(m) ? 'undef' : m.toFixed(2)}`;
                            }
                        }
                    }
                }
            }
        });
    }

    window.onload = () => {
        addNewLine();
        draw();
    };
    document.addEventListener('keydown', (e) => { if(e.key === 'Enter') draw(); });
</script>
</body>
</html>
