<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>霓虹西洋棋：AAA 物理輝光・浮空城版</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/objects/Sky.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        .hud { position: absolute; color: #fff; text-shadow: 0 0 10px rgba(0,0,0,0.8); pointer-events: auto; }
        #status-panel { top: 30px; right: 30px; text-align: right; }
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 4px; color: #ffcc00; font-weight: 300; text-transform: uppercase; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 10px; }
        #turn-txt { font-size: 2.5rem; font-weight: 900; color: #fff; text-shadow: 0 0 20px rgba(0,229,255,0.6); }
        #log-panel { bottom: 30px; left: 30px; width: 350px; font-size: 12px; opacity: 0.8; font-family: monospace; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 4px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ffcc00; font-size: 24px; font-weight: bold; letter-spacing: 2px; text-shadow: 0 0 30px #ffcc00; z-index: 999; }
    </style>
</head>
<body>

<div id="loading">INITIALIZING PHYSICS & BLOOM ENGINE...</div>

<div id="ui" style="display:none;">
    <div id="status-panel" class="hud">
        <h1>FLOATING FORTRESS</h1>
        <div id="turn-txt">BLUE TURN</div>
    </div>
    <div id="log-panel" class="hud">
        <div id="move-log">System Ready.<br>Wind Physics: Active.<br>Global Illumination: Simulated.</div>
    </div>
</div>

<script>
// --- 核心變數 ---
let scene, camera, renderer, controls, raycaster, mouse, clock;
let composer; // 後處理合成器
let game = new Chess();
let tilesMap = {}, piecesMap = {};
let selectedSquare = null, isProcessing = false;
let grassMat, treeLeafMat;
let sunSprite;

const BOARD_HEIGHT = 12; // 棋盤懸浮高度
const CHESS_NAMES = { k: 'KING', q: 'QUEEN', r: 'ROOK', b: 'BISHOP', n: 'KNIGHT', p: 'PAWN' };

function init() {
    clock = new THREE.Clock();
    scene = new THREE.Scene();
    
    // 1. 氛圍：黃金時刻，但天空更清澈
    scene.fog = new THREE.FogExp2(0xffaa77, 0.001); 
    scene.background = new THREE.Color(0x331111);

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 35, 45); // 視角拉高，看清懸浮感

    // 2. 渲染器設置 (開啟 HDR 高動態範圍)
    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.9;
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 1.8; // 允許看到天空
    controls.minDistance = 10; controls.maxDistance = 200;
    controls.target.set(0, BOARD_HEIGHT, 0); // 鎖定懸浮棋盤

    setupLightingAndSun();
    setupPostProcessing(); // 啟動 AAA 輝光

    // 延遲生成場景
    setTimeout(() => {
        createLushTerrain(); // 綠色草原
        createFloatingBoard(); // 懸浮棋盤
        createRealisticTrees(); // 風動樹木
        createClouds();
        syncPieces();
        document.getElementById('loading').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
    }, 100);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    window.addEventListener('click', onMouseClick);
    window.addEventListener('resize', onResize);

    animate();
}

// --- 1. 後處理：Bloom (輝光) ---
function setupPostProcessing() {
    const renderScene = new THREE.RenderPass(scene, camera);
    
    // Unreal Bloom 參數：(解析度, 強度, 半徑, 閾值)
    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.strength = 0.6; // 輝光強度
    bloomPass.radius = 0.5;   // 擴散半徑
    bloomPass.threshold = 0.7; // 只有亮的地方會發光

    composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);
}

// --- 2. 太陽：光暈精靈 (不再是球) ---
function setupLightingAndSun() {
    const ambient = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambient);

    const sunLight = new THREE.DirectionalLight(0xffaa33, 2.5);
    sunLight.position.set(-200, 100, -200);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.set(4096, 4096);
    const d = 400;
    sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d;
    sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
    scene.add(sunLight);

    // Sky Shader
    const sky = new THREE.Sky(); sky.scale.setScalar(450000); scene.add(sky);
    const uniforms = sky.material.uniforms;
    uniforms['turbidity'].value = 5;
    uniforms['rayleigh'].value = 2;
    uniforms['mieCoefficient'].value = 0.005;
    uniforms['mieDirectionalG'].value = 0.8;
    uniforms['sunPosition'].value.copy(sunLight.position);

    // 真實太陽光暈 (Canvas 繪製 Sprite)
    const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(256,256,0,256,256,256);
    grad.addColorStop(0, 'rgba(255, 255, 255, 1)'); // 核心極亮
    grad.addColorStop(0.2, 'rgba(255, 200, 100, 0.8)'); // 中層金黃
    grad.addColorStop(0.5, 'rgba(255, 100, 0, 0.3)'); // 外層橘紅
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)'); // 邊緣透明
    ctx.fillStyle = grad; ctx.fillRect(0,0,512,512);
    
    const tex = new THREE.CanvasTexture(canvas);
    const mat = new THREE.SpriteMaterial({ map: tex, blending: THREE.AdditiveBlending, depthWrite: false });
    sunSprite = new THREE.Sprite(mat);
    sunSprite.scale.set(800, 800, 1);
    sunSprite.position.copy(sunLight.position).normalize().multiplyScalar(3000);
    scene.add(sunSprite);
}

// --- 3. 場景：懸浮棋盤 & 綠色草原 ---
function createFloatingBoard() {
    // 懸浮底座 (反重力裝置)
    const baseGeo = new THREE.CylinderGeometry(1, 10, 4, 8);
    const baseMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4, metalness: 0.8 });
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.position.y = BOARD_HEIGHT - 2.2;
    base.castShadow = true;
    scene.add(base);

    // 發光能量環
    const ringGeo = new THREE.TorusGeometry(6, 0.2, 16, 100);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0x00e5ff });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI / 2;
    ring.position.y = BOARD_HEIGHT - 4;
    scene.add(ring);
    
    // 動畫：能量環緩慢旋轉
    new TWEEN.Tween(ring.rotation).to({z: Math.PI*2}, 10000).repeat(Infinity).start();

    // 棋盤本體
    const boardBox = new THREE.Mesh(
        new THREE.BoxGeometry(9, 0.5, 9), 
        new THREE.MeshStandardMaterial({color: 0x222222, roughness: 0.2})
    );
    boardBox.position.y = BOARD_HEIGHT - 0.25;
    boardBox.receiveShadow = true;
    scene.add(boardBox);

    // 格子
    for(let r=0;r<8;r++)for(let c=0;c<8;c++){
        const n=String.fromCharCode(97+c)+(r+1), isW=(r+c)%2!==0;
        const t=new THREE.Mesh(new THREE.BoxGeometry(1,0.2,1), new THREE.MeshStandardMaterial({
            color:isW?0xffffff:0x444444, roughness:0.1, metalness:0.2 // 高反光材質
        }));
        t.position.set(c-3.5, BOARD_HEIGHT, 3.5-r); 
        t.userData={square:n,isTile:true}; t.receiveShadow=true; t.castShadow=true;
        scene.add(t); tilesMap[n]=t;
    }
}

function createLushTerrain() {
    // 地面：起伏的綠色草原
    const geo = new THREE.PlaneGeometry(2000, 2000, 128, 128);
    geo.rotateX(-Math.PI / 2);
    const pos = geo.attributes.position;
    for(let i=0; i<pos.count; i++){
        const x = pos.getX(i), z = pos.getZ(i);
        const dist = Math.sqrt(x*x + z*z);
        let h = 0;
        if(dist > 30) {
            h += Math.sin(x*0.01)*Math.cos(z*0.01)*20;
            h += Math.sin(x*0.05 + z*0.02)*5;
        }
        pos.setY(i, h-20); // 放在棋盤下方遠處
    }
    geo.computeVertexNormals();
    
    const mat = new THREE.MeshStandardMaterial({ color: 0x1e3a1e, roughness: 1.0 }); // 深綠底色
    const terrain = new THREE.Mesh(geo, mat);
    terrain.receiveShadow = true;
    scene.add(terrain);

    // 茂密的草 (Shader Wind)
    const bGeo = new THREE.PlaneGeometry(0.2, 1.0); bGeo.translate(0, 0.5, 0);
    grassMat = new THREE.MeshStandardMaterial({ color: 0x44aa44, side: THREE.DoubleSide });
    grassMat.onBeforeCompile = s => {
        s.uniforms.time={value:0}; 
        s.vertexShader=`uniform float time;\n`+s.vertexShader;
        // 風力算法：Sine波 + 噪聲
        s.vertexShader=s.vertexShader.replace(`#include <begin_vertex>`, 
        `vec3 transformed=vec3(position);
         float wind = sin(time*1.5 + position.x*0.1 + position.z*0.1) * 0.3 * position.y;
         float gust = sin(time*3.0 + position.x*0.5) * 0.1 * position.y;
         transformed.x += wind + gust;
         #include <begin_vertex>`);
        grassMat.userData.shader=s;
    };

    const count = 30000;
    const iGrass = new THREE.InstancedMesh(bGeo, grassMat, count);
    const dummy = new THREE.Object3D();
    for(let i=0; i<count; i++) {
        const theta = Math.random()*Math.PI*2;
        const r = Math.random()*200; // 草原半徑
        const x=Math.cos(theta)*r, z=Math.sin(theta)*r;
        dummy.position.set(x, -20 + Math.sin(x*0.01)*Math.cos(z*0.01)*20 + Math.sin(x*0.05+z*0.02)*5, z); // 貼合地形
        dummy.rotation.y = Math.random()*Math.PI;
        dummy.scale.setScalar(0.8+Math.random());
        dummy.updateMatrix();
        iGrass.setMatrixAt(i, dummy.matrix);
    }
    iGrass.receiveShadow = true;
    scene.add(iGrass);
}

function createRealisticTrees() {
    const group = new THREE.Group();
    // 樹葉材質 (也會隨風動)
    treeLeafMat = new THREE.MeshStandardMaterial({ color: 0x2d4c1e, flatShading: true });
    treeLeafMat.onBeforeCompile = s => {
        s.uniforms.time={value:0}; s.vertexShader=`uniform float time;\n`+s.vertexShader;
        s.vertexShader=s.vertexShader.replace(`#include <begin_vertex>`, 
        `vec3 transformed=vec3(position);
         float sway = sin(time + position.x) * 0.2; 
         transformed.x += sway; 
         #include <begin_vertex>`);
        treeLeafMat.userData.shader=s;
    };

    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3d2817 });
    
    // 圍繞棋盤種植
    for(let i=0; i<100; i++) {
        const theta = Math.random()*Math.PI*2;
        const r = 80 + Math.random()*200; // 在草原外圍
        const x=Math.cos(theta)*r, z=Math.sin(theta)*r;
        const y = -20 + Math.sin(x*0.01)*Math.cos(z*0.01)*20; // 貼合地形
        
        const tree = new THREE.Group();
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 5, 6), trunkMat);
        trunk.position.y = 2.5; trunk.castShadow=true; tree.add(trunk);
        
        for(let j=0; j<5; j++) {
            const leaf = new THREE.Mesh(new THREE.DodecahedronGeometry(2.5), treeLeafMat);
            leaf.position.set((Math.random()-0.5)*3, 5+Math.random()*3, (Math.random()-0.5)*3);
            leaf.scale.setScalar(0.8+Math.random()); leaf.castShadow=true; tree.add(leaf);
        }
        tree.position.set(x, y, z);
        group.add(tree);
    }
    scene.add(group);
}

function createClouds() {
    const cv = document.createElement('canvas'); cv.width=128; cv.height=128;
    const cx = cv.getContext('2d'), g = cx.createRadialGradient(64,64,0,64,64,64);
    g.addColorStop(0, 'rgba(255, 220, 180, 0.4)'); 
    g.addColorStop(1, 'rgba(0,0,0,0)');
    cx.fillStyle = g; cx.fillRect(0,0,128,128);
    const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(cv), transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
    
    for(let i=0; i<30; i++) {
        const cl = new THREE.Group();
        for(let j=0; j<20; j++) {
            const p = new THREE.Sprite(mat); 
            p.position.set((Math.random()-0.5)*40, (Math.random()-0.5)*15, (Math.random()-0.5)*40); 
            p.scale.setScalar(20+Math.random()*20); cl.add(p);
        }
        cl.position.set((Math.random()-0.5)*600, 150+Math.random()*50, (Math.random()-0.5)*600);
        scene.add(cl);
    }
}

// --- 4. 真 3D 棋子 (保持之前的好評模型) ---
function createMeshPiece(type, color) {
    const group = new THREE.Group();
    // 材質升級：更強的反光與自發光
    const mat = new THREE.MeshStandardMaterial({
        color: color === 'w' ? 0xffffff : 0x111111,
        roughness: 0.1, metalness: 0.6
    });
    const glowMat = new THREE.MeshStandardMaterial({
        color: color === 'w' ? 0x00e5ff : 0xff0055,
        emissive: color === 'w' ? 0x00e5ff : 0xff0055,
        emissiveIntensity: 3.0 // 配合 Bloom 超亮
    });

    const base = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.45, 0.2, 32), mat);
    base.position.y = 0.1; base.castShadow = true; group.add(base);

    // 簡化的幾何構建邏輯 (與上一版相同，但材質增強)
    if(type==='p'){
        const b=new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.35,0.6,16),mat);b.position.y=0.5;b.castShadow=true;
        const h=new THREE.Mesh(new THREE.SphereGeometry(0.25,32,32),mat);h.position.y=0.95;h.castShadow=true;group.add(b,h);
    } else if(type==='r'){
        const b=new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.35,0.8,32),mat);b.position.y=0.6;b.castShadow=true;
        const t=new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,0.3,32),mat);t.position.y=1.1;t.castShadow=true;
        const r=new THREE.Mesh(new THREE.TorusGeometry(0.2,0.05,16,32),glowMat);r.position.y=1.25;r.rotation.x=Math.PI/2;group.add(b,t,r);
    } else if(type==='n'){
        const b=new THREE.Mesh(new THREE.CylinderGeometry(0.25,0.35,0.6,16),mat);b.position.y=0.5;b.castShadow=true;
        const h=new THREE.Mesh(new THREE.BoxGeometry(0.3,0.6,0.2),mat);h.position.set(0,1.0,0.1);h.rotation.x=-Math.PI/6;h.castShadow=true;
        const m=new THREE.Mesh(new THREE.BoxGeometry(0.1,0.5,0.05),glowMat);m.position.set(0,1.1,-0.15);m.rotation.x=-Math.PI/6;group.add(b,h,m);
        if(color==='b')group.rotation.y=Math.PI;
    } else if(type==='b'){
        const b=new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.35,1.0,16),mat);b.position.y=0.7;b.castShadow=true;
        const t=new THREE.Mesh(new THREE.SphereGeometry(0.08),glowMat);t.position.y=1.7;group.add(b,t);
    } else if(type==='q'){
        const b=new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.4,1.4,32),mat);b.position.y=0.9;b.castShadow=true;
        const t=new THREE.Mesh(new THREE.SphereGeometry(0.15),glowMat);t.position.y=1.7;group.add(b,t);
    } else if(type==='k'){
        const b=new THREE.Mesh(new THREE.CylinderGeometry(0.25,0.45,1.6,32),mat);b.position.y=1.0;b.castShadow=true;
        const c=new THREE.Mesh(new THREE.BoxGeometry(0.1,0.4,0.1),glowMat);c.position.y=1.95;group.add(b,c);
    }
    return group;
}

function syncPieces(){
    for(let sq in piecesMap) scene.remove(piecesMap[sq]); piecesMap={}; const b=game.board();
    for(let r=0;r<8;r++)for(let c=0;c<8;c++){const p=b[r][c];if(p){const sq=String.fromCharCode(97+c)+(8-r),s=createMeshPiece(p.type,p.color);s.position.set(c-3.5, BOARD_HEIGHT, r-3.5);scene.add(s);piecesMap[sq]=s;}}
}

// --- 5. 物理動畫 (Bounce & Tilt) ---
function animateMove(m){
    isProcessing=true; clearHighlights();
    const s=piecesMap[m.from];
    const targetPos = tilesMap[m.to].position.clone();
    
    if(m.captured&&piecesMap[m.to])scene.remove(piecesMap[m.to]);

    // 1. 移動動畫 (水平)
    new TWEEN.Tween(s.position)
        .to({x: targetPos.x, z: targetPos.z}, 500)
        .easing(TWEEN.Easing.Quadratic.Out)
        .start();

    // 2. 彈跳動畫 (垂直) - 模擬物理落地
    // 上升 -> 落下 -> 彈起 -> 落下
    const jumpHeight = 1.5;
    new TWEEN.Tween(s.position)
        .to({y: BOARD_HEIGHT + jumpHeight}, 250)
        .easing(TWEEN.Easing.Cubic.Out)
        .chain(
            new TWEEN.Tween(s.position)
            .to({y: BOARD_HEIGHT}, 500) // 落地
            .easing(TWEEN.Easing.Bounce.Out) // 關鍵：彈跳效果
            .onComplete(()=>{
                syncPieces(); updateStatus();
                if(game.game_over())return;
                if(game.turn()==='b')setTimeout(makeRandomAI,500);else isProcessing=false;
            })
        ).start();
        
    // 3. 傾斜動畫 (模擬慣性)
    s.rotation.z = -0.2; // 前傾
    new TWEEN.Tween(s.rotation).to({z: 0}, 600).delay(200).easing(TWEEN.Easing.Elastic.Out).start();
}

// --- 交互 ---
function onMouseClick(e){if(isProcessing)return;mouse.x=(e.clientX/window.innerWidth)*2-1;mouse.y=-(e.clientY/window.innerHeight)*2+1;raycaster.setFromCamera(mouse,camera);const i=raycaster.intersectObjects(Object.values(tilesMap));if(i.length>0)handleInteraction(i[0].object.userData.square);}
function handleInteraction(sq){const p=game.get(sq);if(!selectedSquare){if(p&&p.color==='w'&&game.turn()==='w')selectSquare(sq);}else{if(p&&p.color==='w'){selectSquare(sq);return;}const m=game.move({from:selectedSquare,to:sq,promotion:'q'});if(m)animateMove(m);else{clearHighlights();selectedSquare=null;}}}
function selectSquare(sq){clearHighlights();selectedSquare=sq;tilesMap[sq].material.emissive.setHex(0xffff00);tilesMap[sq].material.emissiveIntensity=0.8;game.moves({square:sq,verbose:true}).forEach(m=>{tilesMap[m.to].material.emissive.setHex(m.captured?0xff3300:0x00aaff);tilesMap[m.to].material.emissiveIntensity=0.5;});}
function clearHighlights(){for(let sq in tilesMap){tilesMap[sq].material.emissive.setHex(0x000000);tilesMap[sq].material.emissiveIntensity=0;}}
function makeRandomAI(){const ms=game.moves();if(ms.length===0)return;game.move(ms[Math.floor(Math.random()*ms.length)]);syncPieces();updateStatus();isProcessing=false;}
function updateStatus(){const t=document.getElementById('turn-txt');t.innerText=game.turn()==='w'?"BLUE TURN":"AI TURN";t.style.color=game.turn()==='w'?"#00e5ff":"#ff0055";}
function onResize(){camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);composer.setSize(window.innerWidth,window.innerHeight);}

function animate(){
    requestAnimationFrame(animate); 
    const t=clock.getElapsedTime(); 
    TWEEN.update(); controls.update();
    
    // Shader 更新
    if(grassMat&&grassMat.userData.shader)grassMat.userData.shader.uniforms.time.value=t;
    if(treeLeafMat&&treeLeafMat.userData.shader)treeLeafMat.userData.shader.uniforms.time.value=t;

    // 使用 Composer 渲染 (包含 Bloom)
    composer.render();
}
init();
</script>
</body>
</html>
