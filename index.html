<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>二次元西洋棋：正統開局版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Segoe UI', sans-serif; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .panel { position: absolute; background: rgba(0,0,0,0.85); color: white; padding: 20px; border-radius: 12px; pointer-events: auto; border: 1px solid #81b64c; }
        #gacha-panel { top: 20px; left: 20px; width: 260px; }
        #status-panel { top: 20px; right: 20px; text-align: right; }
        .btn { background: #81b64c; color: white; border: none; padding: 12px; border-radius: 6px; cursor: pointer; font-weight: bold; width: 100%; margin-top: 10px; }
        .btn:hover { background: #a3d160; }
        .info-text { font-size: 14px; color: #ccc; margin-top: 5px; }
    </style>
</head>
<body>

<div id="ui">
    <div id="gacha-panel" class="panel">
        <h2 style="margin:0 0 10px 0; color:#81b64c;">召喚祭壇</h2>
        <div id="count">點擊召喚以解鎖角色 Skin</div>
        <button id="draw-btn" class="btn">進行召喚</button>
        <button id="start-btn" class="btn" style="display:none; background:#4581c5">標準開局</button>
        <div class="info-text">※ 召喚滿 16 次後依標準規則佈陣</div>
    </div>
    <div id="status-panel" class="panel">
        <div style="font-size: 1.2em;">回合：<span id="turn-display" style="color:#00e5ff">白方 (你)</span></div>
        <div id="msg" style="font-size: 0.9em; color:#aaa; margin-top:5px;">準備就緒</div>
    </div>
</div>

<script>
let scene, camera, renderer, raycaster, mouse;
let board = [], pieces = [], playerDrawn = [];
let selectedPiece = null, currentTurn = 'white', gameState = 'drawing';

// 西洋棋標準角色順序 (由左至右)
const STANDARD_ORDER = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
const ROLES_INFO = {
    king: { label: '♔', name: 'KING' },
    queen: { label: '♕', name: 'QUEEN' },
    rook: { label: '♖', name: 'ROOK' },
    knight: { label: '♘', name: 'KNIGHT' },
    bishop: { label: '♗', name: 'BISHOP' },
    pawn: { label: '♙', name: 'PAWN' }
};

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 10);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambient);

    // 棋盤
    for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
            const geo = new THREE.PlaneGeometry(0.98, 0.98);
            const mat = new THREE.MeshBasicMaterial({ color: (r+c)%2===0 ? 0xeeeed2 : 0x769656 });
            const tile = new THREE.Mesh(geo, mat);
            tile.rotation.x = -Math.PI / 2;
            tile.position.set(c-3.5, 0, r-3.5);
            tile.userData = { row: r, col: c, isTile: true, defaultColor: mat.color.clone() };
            scene.add(tile);
            board.push(tile);
        }
    }

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    window.addEventListener('click', onClick);
    animate();
}

// 抽卡 (純粹解鎖 Skin 感)
document.getElementById('draw-btn').onclick = () => {
    if(playerDrawn.length >= 16) return;
    playerDrawn.push({ id: Math.random() });
    document.getElementById('count').innerText = `已解鎖 Skin: ${playerDrawn.length}/16`;
    if(playerDrawn.length === 16) {
        document.getElementById('draw-btn').style.display='none';
        document.getElementById('start-btn').style.display='block';
    }
};

document.getElementById('start-btn').onclick = () => {
    gameState = 'playing';
    document.getElementById('gacha-panel').style.display = 'none';
    setupStandardGame();
};

function setupStandardGame() {
    // 白方
    STANDARD_ORDER.forEach((type, c) => createPiece(type, 'white', 0, c));
    for(let c=0; c<8; c++) createPiece('pawn', 'white', 1, c);
    // 黑方
    STANDARD_ORDER.forEach((type, c) => createPiece(type, 'black', 7, c));
    for(let c=0; c<8; c++) createPiece('pawn', 'black', 6, c);
}

function createPiece(type, side, r, c) {
    const info = ROLES_INFO[type];
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 384;
    const ctx = canvas.getContext('2d');
    
    // 敵我鮮明配色：白方青色，黑方紫色
    const themeColor = side === 'white' ? '#00e5ff' : '#9d00ff';
    ctx.fillStyle = themeColor;
    ctx.fillRect(0, 0, 256, 384);
    
    // 角色圖示
    ctx.fillStyle = 'white';
    ctx.font = 'bold 180px serif'; ctx.textAlign = 'center';
    ctx.fillText(info.label, 128, 220);
    
    // 底部名稱標註
    ctx.font = 'bold 40px Arial';
    ctx.fillText(info.name, 128, 330);
    
    // 外邊框
    ctx.strokeStyle = 'white'; ctx.lineWidth = 15;
    ctx.strokeRect(0,0,256,384);

    const tex = new THREE.CanvasTexture(canvas);
    const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 1.2), mat);
    mesh.userData = { r, c, side, type, isPiece: true };
    updatePiecePos(mesh);
    scene.add(mesh);
    pieces.push(mesh);
}

function updatePiecePos(p) {
    p.position.set(p.userData.c - 3.5, 0.6, p.userData.r - 3.5);
}

// 標準棋規 (簡化版邏輯，確保嚴謹)
function getMoves(p) {
    const { r, c, type, side } = p.userData;
    let moves = [];
    const enemy = side === 'white' ? 'black' : 'white';
    const getPiece = (rr, cc) => pieces.find(x => x.userData.r === rr && x.userData.c === cc);

    if (type === 'pawn') {
        const dir = side === 'white' ? 1 : -1;
        if (r+dir>=0 && r+dir<=7 && !getPiece(r+dir, c)) moves.push({r: r+dir, c});
        [-1, 1].forEach(dc => {
            const t = getPiece(r+dir, c+dc);
            if (t && t.userData.side === enemy) moves.push({r: r+dir, c: c+dc});
        });
    } else if (type === 'knight') {
        [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(d=>{
            const rr=r+d[0], cc=c+d[1];
            if(rr>=0&&rr<=7&&cc>=0&&cc<=7) {
                const t=getPiece(rr,cc);
                if(!t || t.userData.side===enemy) moves.push({r:rr,c:cc});
            }
        });
    } else if (type === 'king') {
        for(let dr=-1; dr<=1; dr++){
            for(let dc=-1; dc<=1; dc++){
                if(dr===0 && dc===0) continue;
                const rr=r+dr, cc=c+dc;
                if(rr>=0&&rr<=7&&cc>=0&&cc<=7){
                    const t=getPiece(rr,cc);
                    if(!t||t.userData.side===enemy) moves.push({r:rr,c:cc});
                }
            }
        }
    } else {
        let dirs = [];
        if(type==='rook') dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        if(type==='bishop') dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
        if(type==='queen') dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
        dirs.forEach(d=>{
            let rr=r+d[0], cc=c+d[1];
            while(rr>=0&&rr<=7&&cc>=0&&cc<=7){
                const t=getPiece(rr,cc);
                if(!t) moves.push({r:rr,c:cc});
                else { if(t.userData.side===enemy) moves.push({r:rr,c:cc}); break; }
                rr+=d[0]; cc+=d[1];
            }
        });
    }
    return moves;
}

function onClick(e) {
    if(gameState !== 'playing' || currentTurn === 'black') return;
    mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(scene.children);
    if(hits.length > 0) {
        const obj = hits[0].object;
        if(obj.userData.isPiece && obj.userData.side === 'white') {
            selectedPiece = obj;
            highlight(getMoves(obj));
        } else if(selectedPiece) {
            const hit = hits.find(h => h.object.userData.isTile || h.object.userData.isPiece);
            if(hit) {
                const target = hit.object.userData;
                const tr = target.r !== undefined ? target.r : target.row;
                const tc = target.c !== undefined ? target.c : target.col;
                if(getMoves(selectedPiece).some(m => m.r === tr && m.c === tc)) doMove(selectedPiece, tr, tc);
            }
        }
    }
}

function doMove(p, r, c) {
    const enemy = pieces.find(x => x.userData.r === r && x.userData.c === c);
    if(enemy) {
        scene.remove(enemy);
        pieces = pieces.filter(x => x !== enemy);
        if(enemy.userData.type === 'king') alert(p.userData.side === 'white' ? "恭喜獲勝！" : "你輸了...");
    }
    p.userData.r = r; p.userData.c = c;
    updatePiecePos(p);
    resetBoard();
    selectedPiece = null;
    currentTurn = currentTurn === 'white' ? 'black' : 'white';
    const turnDisp = document.getElementById('turn-display');
    turnDisp.innerText = currentTurn === 'white' ? "白方 (你)" : "黑方 (AI)";
    turnDisp.style.color = currentTurn === 'white' ? "#00e5ff" : "#9d00ff";
    if(currentTurn === 'black') setTimeout(simpleAI, 800);
}

function simpleAI() {
    const blacks = pieces.filter(x => x.userData.side === 'black');
    // 優先吃子
    for(let p of blacks) {
        const ms = getMoves(p);
        for(let m of ms) {
            if(pieces.find(x => x.userData.r === m.r && x.userData.c === m.c && x.userData.side === 'white')) {
                doMove(p, m.r, m.c); return;
            }
        }
    }
    // 隨機移動
    const p = blacks[Math.floor(Math.random()*blacks.length)];
    const ms = getMoves(p);
    if(ms.length > 0) doMove(p, ms[0].r, ms[0].c);
    else currentTurn = 'white';
}

function highlight(moves) {
    resetBoard();
    moves.forEach(m => {
        const t = board.find(x => x.userData.row === m.r && x.userData.col === m.c);
        if(t) t.material.color.set(0x81b64c);
    });
}
function resetBoard() { board.forEach(t => t.material.color.copy(t.userData.defaultColor)); }
function animate() {
    requestAnimationFrame(animate);
    pieces.forEach(p => { p.position.y = 0.6 + Math.sin(Date.now()*0.004 + p.userData.r)*0.06; });
    renderer.render(scene, camera);
}
init();
</script>
</body>
</html>
