<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>éœ“è™¹è¥¿æ´‹æ£‹ï¼šDTZ æœ€çµ‚è¡Œå‹•å„ªåŒ–ç‰ˆ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/objects/Sky.js"></script>

    <script type="importmap">
    {
        "imports": {
            "firebase/app": "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js",
            "firebase/database": "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js",
            "firebase/auth": "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js"
        }
    }
    </script>

    <style>
        /* --- æ ¸å¿ƒå„ªåŒ–ï¼šç¦æ­¢é¸å–èˆ‡åŸç”Ÿè§¸æ§æ»¾å‹• --- */
        body { 
            margin: 0; overflow: hidden; background: #000; 
            font-family: 'Microsoft JhengHei', sans-serif; 
            color: white; 
            touch-action: none; /* é—œéµï¼šé˜²æ­¢æ‰‹æ©Ÿç€è¦½å™¨ä¸‹æ‹‰åˆ·æ–°æˆ–æ»¾å‹• */
            user-select: none;  /* é˜²æ­¢é•·æŒ‰é¸å–æ–‡å­— */
            -webkit-user-select: none;
        }
        
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        .hud { position: absolute; pointer-events: auto; }
        
        /* --- ç™»å…¥è¦–çª— RWD å„ªåŒ– --- */
        #auth-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 2000; display: flex;
            justify-content: center; align-items: center; pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        .auth-box {
            background: rgba(20, 20, 30, 0.95); border: 1px solid #00e5ff;
            padding: 30px 20px; border-radius: 15px; 
            width: 90%; max-width: 320px; /* æ‰‹æ©Ÿç‰ˆå¯¬åº¦è‡ªé©æ‡‰ */
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 229, 255, 0.2); 
        }
        .auth-input {
            width: 100%; padding: 12px; margin: 8px 0;
            background: #111; border: 1px solid #444; color: #fff;
            border-radius: 6px; box-sizing: border-box; font-size: 16px; /* 16px é˜²æ­¢ iOS è¼¸å…¥æ™‚ç¸®æ”¾ */
        }
        .auth-btn, .guest-btn {
            width: 100%; padding: 12px; margin-top: 5px; border-radius: 6px; font-size: 16px;
            cursor: pointer; font-weight: bold; border: none;
        }
        .auth-btn { background: #00e5ff; color: #000; }
        .guest-btn { background: transparent; color: #aaa; border: 1px solid #444; }

        /* --- éŠæˆ²å…§ä»‹é¢å„ªåŒ– --- */
        #status-panel { 
            top: 20px; right: 20px; text-align: right; 
            background: linear-gradient(to left, rgba(0, 255, 255, 0.1), rgba(0,0,0,0)); 
            padding: 15px; border-right: 3px solid #00e5ff; 
        }
        #menu-panel { 
            top: 20px; left: 20px; 
            background: rgba(0,0,0,0.8); padding: 15px; 
            border-radius: 8px; border: 1px solid #333; width: 240px;
        }
        
        button.game-btn { 
            background: #00e5ff; color: #000; border: none; 
            padding: 12px; margin-top: 8px; width: 100%; /* åŠ å¤§é»æ“Šå€åŸŸ */
            font-weight: bold; cursor: pointer; border-radius: 4px; font-size: 14px;
        }
        
        /* --- æ‰‹æ©Ÿç‰ˆé¢é…ç½® (Media Query) --- */
        @media (max-width: 600px) {
            /* ç‹€æ…‹åˆ—ç§»åˆ°åº•éƒ¨ï¼Œé˜²æ­¢æ“‹ä½ä¸Šæ–¹è¦–ç·š */
            #status-panel { 
                top: auto; bottom: 0; left: 0; right: 0; 
                text-align: center; border-right: none; border-top: 2px solid #00e5ff; 
                background: rgba(0,0,0,0.9); padding: 10px;
            }
            #status-panel h1 { font-size: 1rem; display: inline-block; margin-right: 10px; }
            #turn-txt { font-size: 1.2rem; display: inline-block; }
            
            /* é¸å–®æ”¹ç‚ºå·¦ä¸Šè§’ç¸®å°ç‰ˆï¼Œé»æ“Šå±•é–‹ (é€™è£¡ç°¡åŒ–ç‚ºå›ºå®šå·¦ä¸Š) */
            #menu-panel { 
                top: 10px; left: 10px; width: 180px; padding: 10px;
                transform: scale(0.9); transform-origin: top left;
            }
            
            /* æ•™å­¸æŒ‰éˆ•ä¸Šç§»ï¼Œé¿é–‹åº•éƒ¨çš„ç‹€æ…‹åˆ— */
            #tutorial-btn { bottom: 80px; right: 10px; width: 35px; height: 35px; font-size: 16px;}
            #tutorial-content { bottom: 120px; right: 10px; left: 10px; width: auto; max-height: 50vh; }
            
            #footer-watermark { display: none; } /* æ‰‹æ©Ÿéš±è—æµ®æ°´å°ä»¥ç¯€çœç©ºé–“ */
        }
        
        /* å…¶ä»–æ¨£å¼ç¶­æŒåŸæ¨£ */
        #loading { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; justify-content: center; align-items: center; color: #ffaa00; font-size: 18px; z-index: 1500; }
        .user-card { margin-bottom: 10px; border-bottom: 1px solid #444; padding-bottom: 5px; }
        
        /* éš±è—å…ƒç´  */
        #nickname-container { display: none; margin-top: 5px; }
        .rank-badge { padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-left: 5px; font-weight: bold; }
        .rank-bronze { background: #cd7f32; color: #000; }
        .rank-silver { background: #c0c0c0; color: #000; }
        .rank-gold { background: #ffd700; color: #000; }
        
        /* æ•™å­¸ç›¸é—œ */
        #tutorial-btn {
            position: absolute; bottom: 20px; right: 20px;
            width: 40px; height: 40px; border-radius: 50%;
            background: rgba(0,0,0,0.7); border: 2px solid #ffaa00;
            color: #ffaa00; display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 110; font-weight: bold;
        }
        #tutorial-content {
            position: absolute; bottom: 70px; right: 20px; width: 280px;
            background: rgba(0, 0, 0, 0.95); border: 1px solid #ffaa00;
            border-radius: 8px; padding: 15px; display: none; z-index: 110;
        }
    </style>
</head>
<body>

<div id="loading">éŠæˆ²è¼‰å…¥ä¸­...</div>

<div id="auth-modal">
    <div class="auth-box">
        <h2 style="color:#00e5ff; margin:0 0 10px 0;">DTZ CHESS</h2>
        <div id="auth-error" style="color:#ff0055; font-size:12px; margin-bottom:10px; min-height:15px;"></div>
        
        <input type="email" id="email" class="auth-input" placeholder="Email">
        <input type="password" id="password" class="auth-input" placeholder="å¯†ç¢¼">
        
        <div id="nickname-container">
            <input type="text" id="nickname" class="auth-input" placeholder="è¼¸å…¥æš±ç¨± (ç”¨æ–¼è¨»å†Š)" style="border-color:#00ff00;">
        </div>

        <button id="auth-action-btn" class="auth-btn">ç™»å…¥ / è¨»å†Š</button>
        <div id="forgot-pw" style="color:#aaa; font-size:12px; margin:10px 0; cursor:pointer;">å¿˜è¨˜å¯†ç¢¼ï¼Ÿ</div>
        <button id="guest-btn" class="guest-btn">è¨ªå®¢è©¦ç©</button>
    </div>
</div>

<div id="ui" style="display:none;">
    <div id="menu-panel" class="hud">
        <div class="user-card">
            <div style="display:flex; justify-content:space-between;">
                <span id="user-name" style="font-weight:bold; color:#fff;">Player</span>
                <span id="user-rank" class="rank-badge rank-bronze">éŠ…ç‰Œ</span>
            </div>
            <div style="font-size:12px; color:#aaa; margin-top:5px;">ELO: <span id="user-elo" style="color:#00e5ff;">0</span></div>
        </div>
        <div id="room-display" style="font-size:12px; color:#0f0; margin-bottom:5px;">ç‹€æ…‹ï¼šé–’ç½®</div>
        <button id="btn-create" class="game-btn">å‰µå»ºæˆ¿é–“ (åŸ·ç™½)</button>
        <button id="btn-join" class="game-btn" style="background:#ff0055; color:#fff;">åŠ å…¥æˆ¿é–“ (åŸ·é»‘)</button>
        <button id="btn-logout" class="game-btn" style="background:#333; color:#aaa; margin-top:10px;">ç™»å‡º</button>
    </div>

    <div id="tutorial-btn" onclick="toggleTutorial()">?</div>
    <div id="tutorial-content" class="hud">
        <h3 style="color:#ffaa00; margin:0 0 10px 0;">æ“ä½œèªªæ˜</h3>
        <ul style="padding-left:20px; color:#ccc; font-size:13px; margin:0;">
            <li>å–®æŒ‡æ‹–æ›³ï¼šæ—‹è½‰è¦–è§’</li>
            <li>é›™æŒ‡ç¸®æ”¾ï¼šé è¿‘èª¿æ•´</li>
            <li>é»æ“Šæ£‹å­ï¼šé¸æ“‡/ç§»å‹•</li>
            <li>æ‰‹æ©Ÿå»ºè­°æ©«å‘éŠç©</li>
        </ul>
    </div>

    <div id="status-panel" class="hud">
        <h1>NEON CHESS</h1>
        <div id="turn-txt">ç­‰å¾…å°æˆ°</div>
        <div id="opponent-info" style="font-size: 12px; color: #aaa;">å°æ‰‹: ---</div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "firebase/app";
    import { getDatabase, ref, set, get, update, onValue } from "firebase/database";
    import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signInAnonymously, onAuthStateChanged, signOut, sendPasswordResetEmail } from "firebase/auth";

    // ==========================================
    // ğŸš€ æ‰‹æ©Ÿæ•ˆèƒ½å„ªåŒ–é…ç½®
    // ==========================================
    const isMobile = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
    
    const CONFIG = {
        // æ‰‹æ©Ÿç‰ˆå¤§å¹…æ¸›å°‘ç‰©ä»¶æ•¸é‡ (å¾ 80000 é™è‡³ 5000)
        grassCount: isMobile ? 5000 : 80000, 
        // æ¸›å°‘æ¨¹æœ¨æ•¸é‡
        treeCount: isMobile ? 150 : 850,
        // é™ä½é™°å½±è²¼åœ–å¤§å° (512 vs 2048)
        shadowSize: isMobile ? 512 : 2048,
        // é™åˆ¶åƒç´ æ¯”ï¼Œé˜²æ­¢é«˜è§£æåº¦æ‰‹æ©Ÿç™¼ç‡™ (Max 1.5)
        pixelRatio: isMobile ? Math.min(window.devicePixelRatio, 1.5) : window.devicePixelRatio,
        // æ‰‹æ©Ÿç‰ˆåœ°å½¢ç´°ç¯€é™ä½
        terrainSegs: isMobile ? 60 : 180
    };

    const firebaseConfig = {
        apiKey: "AIzaSyCxPppnUG864v3E2j1OzykzFmhLpsEJCSE",
        authDomain: "chess-1885a.firebaseapp.com",
        databaseURL: "https://chess-1885a-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "chess-1885a",
        storageBucket: "chess-1885a.firebasestorage.app",
        messagingSenderId: "824383572856",
        appId: "1:824383572856:web:7c663d6bf0f970f6acd68d"
    };

    let app, db, auth;
    try {
        app = initializeApp(firebaseConfig);
        db = getDatabase(app);
        auth = getAuth(app);
    } catch(e) { console.error("Firebase Error", e); }

    let currentUser = null, gameId = null, playerColor = 'w', isOnline = false, isRegistering = false;
    let scene, camera, renderer, controls, raycaster, mouse, clock;
    let game = new Chess();
    let tilesMap = {}, piecesMap = {};
    let selectedSquare = null, isProcessing = false;
    let grassMat, cloudParticles = [];
    const BOARD_HEIGHT = 15;

    // --- ä»‹é¢é‚è¼¯ ---
    window.toggleTutorial = () => {
        const el = document.getElementById('tutorial-content');
        el.style.display = el.style.display === 'none' ? 'block' : 'none';
    };

    const authModal = document.getElementById('auth-modal');
    const authActionBtn = document.getElementById('auth-action-btn');
    const emailInput = document.getElementById('email');
    const passInput = document.getElementById('password');
    const nicknameInput = document.getElementById('nickname');
    const errorMsg = document.getElementById('auth-error');

    onAuthStateChanged(auth, (user) => {
        document.getElementById('loading').style.display = 'none';
        if (user) {
            currentUser = user;
            authModal.style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            checkProfile(user);
        } else {
            currentUser = null;
            authModal.style.display = 'flex';
            document.getElementById('ui').style.display = 'none';
            resetAuthUI();
        }
    });

    function resetAuthUI() {
        isRegistering = false;
        document.getElementById('nickname-container').style.display = 'none';
        authActionBtn.innerText = "ç™»å…¥ / è¨»å†Š";
        errorMsg.innerText = "";
    }

    function checkProfile(user) {
        const userRef = ref(db, 'users/' + user.uid);
        get(userRef).then(snap => {
            if (!snap.exists()) {
                const name = nicknameInput.value.trim() || (user.isAnonymous ? `Guest_${user.uid.substr(0,4)}` : user.email.split('@')[0]);
                set(userRef, { name: name, email: user.email || 'guest', elo: 0 });
            }
            loadProfile();
        });
    }
    
    function loadProfile() {
        if(!currentUser) return;
        onValue(ref(db, 'users/' + currentUser.uid), snap => {
            const d = snap.val();
            if(d) {
                document.getElementById('user-name').innerText = d.name;
                document.getElementById('user-elo').innerText = d.elo;
            }
        });
    }

    authActionBtn.addEventListener('click', async () => {
        const e = emailInput.value.trim(), p = passInput.value.trim();
        if(!e || !p) { errorMsg.innerText = "è«‹è¼¸å…¥å¸³è™Ÿå¯†ç¢¼"; return; }
        
        if (isRegistering) {
            if(!nicknameInput.value.trim()) { errorMsg.innerText = "è«‹è¼¸å…¥æš±ç¨±"; return; }
            try { await createUserWithEmailAndPassword(auth, e, p); } catch(err) { errorMsg.innerText = err.message; }
        } else {
            try { await signInWithEmailAndPassword(auth, e, p); } catch(err) {
                if(err.code === 'auth/user-not-found' || err.code === 'auth/invalid-credential') {
                    isRegistering = true;
                    document.getElementById('nickname-container').style.display = 'block';
                    authActionBtn.innerText = "ç¢ºèªè¨»å†Š";
                    errorMsg.innerText = "å¸³è™Ÿä¸å­˜åœ¨ï¼Œè«‹è¼¸å…¥æš±ç¨±é€²è¡Œè¨»å†Š";
                    errorMsg.style.color = "#00ff00";
                } else { errorMsg.innerText = err.message; }
            }
        }
    });

    document.getElementById('guest-btn').addEventListener('click', () => signInAnonymously(auth));
    document.getElementById('forgot-pw').addEventListener('click', () => {
        const e = emailInput.value.trim();
        if(e) sendPasswordResetEmail(auth, e).then(()=>alert('é‡è¨­ä¿¡å·²å¯„å‡º')).catch(er=>alert(er.message));
        else alert('è«‹å…ˆè¼¸å…¥ Email');
    });
    document.getElementById('btn-logout').addEventListener('click', () => signOut(auth));

    // --- éŠæˆ²æˆ¿é–“é‚è¼¯ ---
    window.createGameRoom = function() {
        gameId = Math.floor(1000 + Math.random() * 9000).toString();
        get(ref(db, 'users/' + currentUser.uid)).then(snap => {
            const u = snap.val();
            set(ref(db, 'games/' + gameId), {
                fen: game.fen(), turn: 'w', white: { uid: currentUser.uid, name: u.name, elo: u.elo },
                status: 'waiting'
            }).then(() => {
                playerColor = 'w'; isOnline = true;
                document.getElementById('room-display').innerText = `æˆ¿è™Ÿ: ${gameId} (ç­‰å¾…ä¸­)`;
                alert(`æˆ¿é–“å·²å»ºç«‹ï¼è™Ÿç¢¼ï¼š${gameId}`);
                setupGameListener();
                resetCamera();
            });
        });
    }

    window.joinGameRoom = function() {
        const id = prompt('è«‹è¼¸å…¥æˆ¿é–“è™Ÿç¢¼:');
        if(!id) return;
        get(ref(db, 'games/' + id)).then(snap => {
            if(snap.exists() && snap.val().status === 'waiting') {
                gameId = id;
                get(ref(db, 'users/' + currentUser.uid)).then(uSnap => {
                    const u = uSnap.val();
                    update(ref(db, 'games/' + gameId), {
                        black: { uid: currentUser.uid, name: u.name, elo: u.elo }, status: 'playing'
                    });
                    playerColor = 'b'; isOnline = true;
                    document.getElementById('room-display').innerText = `æˆ¿è™Ÿ: ${gameId} (å°æˆ°ä¸­)`;
                    game.load(snap.val().fen);
                    syncPieces();
                    setupGameListener();
                    resetCamera();
                });
            } else alert('æˆ¿é–“ä¸å­˜åœ¨æˆ–å·²æ»¿');
        });
    }

    function setupGameListener() {
        onValue(ref(db, 'games/' + gameId), snap => {
            const d = snap.val();
            if(!d) return;
            if(d.black && playerColor === 'w') document.getElementById('opponent-info').innerText = `VS: ${d.black.name}`;
            if(d.white && playerColor === 'b') document.getElementById('opponent-info').innerText = `VS: ${d.white.name}`;
            
            if(d.fen !== game.fen()) {
                game.load(d.fen);
                syncPieces();
                updateHUD();
            }
            if(d.winner) { alert(d.winner === playerColor ? "å‹åˆ©ï¼" : "æˆ°æ•—..."); updateHUD(); }
        });
    }

    function sendMove(m) {
        let updateData = { fen: game.fen(), turn: game.turn() };
        if(game.in_checkmate()) { updateData.winner = game.turn() === 'w' ? 'b' : 'w'; updateData.status = 'finished'; }
        update(ref(db, 'games/' + gameId), updateData);
    }

    function resetCamera() {
        const z = playerColor === 'w' ? 80 : -80; // æ‰‹æ©Ÿç‰ˆæ‹‰è¿‘ä¸€é»
        new TWEEN.Tween(camera.position).to({x:0, y:50, z:z}, 1500).easing(TWEEN.Easing.Cubic.Out).start();
        controls.target.set(0, BOARD_HEIGHT, 0);
    }

    // --- 3D å ´æ™¯é‚è¼¯ (å„ªåŒ–ç‰ˆ) ---
    function getTerrainHeight(x, z) {
        // ç°¡åŒ–è¨ˆç®—
        if(Math.abs(x) < 50 && Math.abs(z) < 50) return -12; // æ£‹ç›¤ä¸­å¿ƒå¹³å¦
        const dist = Math.sqrt(x*x + z*z);
        if (dist < 300) return -12;
        return -12 + (dist - 300) * 0.1 + Math.sin(x*0.02)*5;
    }

    function init() {
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x331111, 0.001); // éœ§æ°£å¢åŠ ä¸€é»é®è”½é è™•
        scene.background = new THREE.Color(0x331111);

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 4000);
        camera.position.set(0, 60, 100);

        renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" }); // æ‰‹æ©Ÿé—œé–‰åé‹¸é½’
        renderer.setPixelRatio(CONFIG.pixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = !isMobile; // æ‰‹æ©Ÿé—œé–‰å³æ™‚é™°å½±ä»¥æå‡ FPS
        if(!isMobile) renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.1;
        controls.minDistance = 20; controls.maxDistance = 300;

        // ç‡ˆå…‰å„ªåŒ–
        const ambient = new THREE.AmbientLight(0xffccaa, 0.8);
        scene.add(ambient);
        
        const dirLight = new THREE.DirectionalLight(0xff8800, 2);
        dirLight.position.set(-100, 100, -100);
        if(!isMobile) {
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = CONFIG.shadowSize;
            dirLight.shadow.mapSize.height = CONFIG.shadowSize;
            dirLight.shadow.camera.left = -200; dirLight.shadow.camera.right = 200;
            dirLight.shadow.camera.top = 200; dirLight.shadow.camera.bottom = -200;
        }
        scene.add(dirLight);

        // å¤©ç©º
        const sky = new THREE.Sky();
        sky.scale.setScalar(450000);
        sky.material.uniforms['turbidity'].value = 10;
        sky.material.uniforms['rayleigh'].value = 2;
        sky.material.uniforms['sunPosition'].value.copy(dirLight.position);
        scene.add(sky);

        // åˆå§‹åŒ–ç‰©ä»¶
        createTerrain();
        createVegetation();
        createBoard();
        syncPieces();

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        window.addEventListener('resize', onResize);
        window.addEventListener('click', onClick);
        window.addEventListener('touchstart', onTouch, {passive: false});

        animate();
    }

    function createTerrain() {
        const geo = new THREE.PlaneGeometry(2000, 2000, CONFIG.terrainSegs, CONFIG.terrainSegs);
        geo.rotateX(-Math.PI/2);
        const pos = geo.attributes.position;
        const colors = [];
        const c1 = new THREE.Color(0x224422), c2 = new THREE.Color(0x443322);
        
        for(let i=0; i<pos.count; i++){
            const x = pos.getX(i), z = pos.getZ(i);
            const h = getTerrainHeight(x, z);
            pos.setY(i, h);
            const alpha = (h + 12) / 50; 
            const c = c1.clone().lerp(c2, Math.min(1, Math.max(0, alpha)));
            colors.push(c.r, c.g, c.b);
        }
        geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geo.computeVertexNormals();
        const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 1, flatShading: true });
        const mesh = new THREE.Mesh(geo, mat);
        if(!isMobile) mesh.receiveShadow = true;
        scene.add(mesh);
    }

    function createVegetation() {
        // æ¨¹æœ¨ (ç°¡åŒ–å¹¾ä½•é«”)
        const tGeo = new THREE.CylinderGeometry(0, 1.5, 8, 5); // æ¸›å°‘é¢æ•¸
        const tMat = new THREE.MeshStandardMaterial({color: 0x113311, flatShading:true});
        const treeMesh = new THREE.InstancedMesh(tGeo, tMat, CONFIG.treeCount);
        const dummy = new THREE.Object3D();
        
        for(let i=0; i<CONFIG.treeCount; i++){
            const r = 100 + Math.random()*800;
            const a = Math.random() * Math.PI * 2;
            const x = Math.cos(a)*r, z = Math.sin(a)*r;
            dummy.position.set(x, getTerrainHeight(x,z)+4, z);
            dummy.scale.setScalar(1 + Math.random());
            dummy.updateMatrix();
            treeMesh.setMatrixAt(i, dummy.matrix);
        }
        if(!isMobile) treeMesh.castShadow = true;
        scene.add(treeMesh);

        // è‰åœ° (ä½¿ç”¨ Shader è®“è‰éš¨é¢¨å‹•ï¼Œä½†åœ¨æ‰‹æ©Ÿä¸Šæ¸›å°‘æ•¸é‡)
        const bGeo = new THREE.PlaneGeometry(0.5, 1.5);
        bGeo.translate(0, 0.75, 0);
        grassMat = new THREE.MeshStandardMaterial({color:0x338833, side:THREE.DoubleSide});
        grassMat.onBeforeCompile = s => {
            s.uniforms.time = {value:0};
            s.vertexShader = `uniform float time;\n` + s.vertexShader;
            s.vertexShader = s.vertexShader.replace(`#include <begin_vertex>`, `vec3 transformed=vec3(position); float w=sin(time*2.0+position.x*0.5)*0.2*position.y; transformed.x+=w; #include <begin_vertex>`);
            grassMat.userData.shader = s;
        };
        const grass = new THREE.InstancedMesh(bGeo, grassMat, CONFIG.grassCount);
        let count = 0;
        for(let i=0; i<CONFIG.grassCount * 2; i++){ // å˜—è©¦ç”Ÿæˆ
            if(count >= CONFIG.grassCount) break;
            const r = Math.random() * 500;
            if(r < 60) continue; // ä¸è¦åœ¨æ£‹ç›¤ä¸­é–“é•·è‰
            const a = Math.random() * Math.PI * 2;
            const x = Math.cos(a)*r, z = Math.sin(a)*r;
            dummy.position.set(x, getTerrainHeight(x,z), z);
            dummy.rotation.y = Math.random()*3;
            dummy.updateMatrix();
            grass.setMatrixAt(count++, dummy.matrix);
        }
        scene.add(grass);
    }

    function createBoard() {
        const base = new THREE.Mesh(new THREE.BoxGeometry(9, 0.5, 9), new THREE.MeshStandardMaterial({color:0x221111}));
        base.position.y = BOARD_HEIGHT - 0.25;
        if(!isMobile) base.receiveShadow = true;
        scene.add(base);

        for(let r=0; r<8; r++) for(let c=0; c<8; c++){
            const n = String.fromCharCode(97+c)+(r+1), w = (r+c)%2!==0;
            const t = new THREE.Mesh(new THREE.BoxGeometry(1, 0.2, 1), new THREE.MeshStandardMaterial({
                color: w ? 0xffddbb : 0x443333, roughness: 0.4
            }));
            t.position.set(c-3.5, BOARD_HEIGHT, 3.5-r);
            t.userData = { square: n };
            if(!isMobile) t.receiveShadow = true;
            scene.add(t);
            tilesMap[n] = t;
        }
    }

    function createPieceMesh(type, color) {
        // ç°¡åŒ–æ£‹å­å¹¾ä½•ï¼Œæå‡æ•ˆèƒ½
        const segs = isMobile ? 12 : 32; 
        const g = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({
            color: color==='w'?0xeeeeff:0x222222, 
            roughness: 0.3, metalness: 0.5
        });
        const glow = new THREE.MeshBasicMaterial({ color: color==='w'?0x00e5ff:0xff0055 }); // ç°¡åŒ–ç™¼å…‰æè³ªï¼Œä¸ç”¨ emissive æ¨™æº–æè³ª

        let geo;
        // ç°¡å–®é€ å‹ä»£æ›¿è¤‡é›œçµ„åˆ
        if(type==='p') geo = new THREE.CylinderGeometry(0.2, 0.3, 0.8, segs);
        else if(type==='r') geo = new THREE.BoxGeometry(0.6, 1, 0.6);
        else if(type==='n') geo = new THREE.CylinderGeometry(0.2, 0.4, 1, 4); // é¦¬ç”¨4é‚Šå½¢æŸ±é«”
        else if(type==='b') geo = new THREE.ConeGeometry(0.3, 1.2, segs);
        else if(type==='q') geo = new THREE.CylinderGeometry(0.3, 0.2, 1.5, segs);
        else if(type==='k') geo = new THREE.CylinderGeometry(0.3, 0.3, 1.6, segs);
        
        const body = new THREE.Mesh(geo, mat);
        body.position.y = 0.5;
        if(!isMobile) body.castShadow = true;
        g.add(body);
        
        // é ‚éƒ¨ç™¼å…‰é»
        const top = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), glow);
        top.position.y = 1.0;
        if(type==='k'||type==='q') top.position.y = 1.6;
        g.add(top);

        return g;
    }

    function syncPieces() {
        for(let s in piecesMap) scene.remove(piecesMap[s]);
        piecesMap = {};
        const b = game.board();
        for(let r=0; r<8; r++) for(let c=0; c<8; c++){
            const p = b[r][c];
            if(p){
                const mesh = createPieceMesh(p.type, p.color);
                mesh.position.set(c-3.5, BOARD_HEIGHT, r-3.5);
                scene.add(mesh);
                piecesMap[String.fromCharCode(97+c)+(8-r)] = mesh;
            }
        }
    }

    function onTouch(e) {
        if(e.touches.length > 1) return; // å…è¨±é›™æŒ‡ç¸®æ”¾
        // e.preventDefault(); // è¨»è§£æ‰ï¼Œå› ç‚º CSS touch-action å·²è™•ç†ï¼Œä¿ç•™éƒ¨åˆ†åŸç”Ÿè¡Œç‚ºæ›´é †æš¢
        mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
        checkIntersection();
    }
    
    function onClick(e) {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        checkIntersection();
    }

    function checkIntersection() {
        if(isProcessing) return;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(Object.values(tilesMap));
        if(intersects.length > 0) handleSquareClick(intersects[0].object.userData.square);
    }

    function handleSquareClick(sq) {
        if(isOnline && game.turn() !== playerColor) return;

        const p = game.get(sq);
        // é¸æ“‡æ£‹å­
        if(!selectedSquare) {
            if(p && p.color === game.turn()) {
                if(isOnline && p.color !== playerColor) return;
                selectSquare(sq);
            }
        } else {
            // ç§»å‹•
            const move = game.move({ from: selectedSquare, to: sq, promotion: 'q' });
            if(move) {
                animateMove(move);
                if(isOnline) sendMove(move);
            } else {
                // å¦‚æœé»æ“ŠåŒè‰²æ£‹å­ï¼Œåˆ‡æ›é¸æ“‡
                if(p && p.color === game.turn() && (!isOnline || p.color === playerColor)) selectSquare(sq);
                else clearSelection();
            }
        }
    }

    function selectSquare(sq) {
        clearSelection();
        selectedSquare = sq;
        tilesMap[sq].material.color.setHex(0xffff00);
        game.moves({square:sq, verbose:true}).forEach(m => {
            tilesMap[m.to].material.color.setHex(m.captured ? 0xff5555 : 0x00ff00); // æ‰‹æ©Ÿç‰ˆç”¨é¡è‰²å€åˆ†æ¯”è¼ƒæ˜é¡¯
        });
    }

    function clearSelection() {
        selectedSquare = null;
        for(let r=0; r<8; r++) for(let c=0; c<8; c++){
            const n = String.fromCharCode(97+c)+(r+1), w = (r+c)%2!==0;
            tilesMap[n].material.color.setHex(w ? 0xffddbb : 0x443333);
        }
    }

    function animateMove(m) {
        isProcessing = true;
        clearSelection();
        const p = piecesMap[m.from];
        delete piecesMap[m.from];
        
        if(m.captured && piecesMap[m.to]) scene.remove(piecesMap[m.to]);
        
        const targetPos = tilesMap[m.to].position.clone();
        new TWEEN.Tween(p.position).to({x:targetPos.x, z:targetPos.z}, 300) // åŠ å¿«ç§»å‹•é€Ÿåº¦
            .easing(TWEEN.Easing.Quadratic.Out)
            .onComplete(() => {
                syncPieces();
                updateHUD();
                isProcessing = false;
                if(!isOnline && game.turn() === 'b') setTimeout(aiMove, 100);
            }).start();
    }

    function aiMove() {
        const moves = game.moves();
        if(moves.length === 0) return;
        const m = moves[Math.floor(Math.random() * moves.length)];
        game.move(m);
        syncPieces();
        updateHUD();
    }

    function updateHUD() {
        const t = document.getElementById('turn-txt');
        const turn = game.turn();
        let txt = turn === 'w' ? "ç™½æ–¹å›åˆ" : "é»‘æ–¹å›åˆ";
        if(isOnline && playerColor === turn) txt += " (ä½ )";
        t.innerText = txt;
        t.style.color = turn === 'w' ? "#00e5ff" : "#ff0055";
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();
        TWEEN.update();
        controls.update();
        if(grassMat && grassMat.userData.shader) grassMat.userData.shader.uniforms.time.value = t;
        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>
