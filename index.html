<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>霓虹西洋棋：真 3D 雕塑版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/objects/Sky.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #88ccee; font-family: 'Segoe UI', sans-serif; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        .hud { position: absolute; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.8); pointer-events: auto; }
        #status-panel { top: 30px; right: 30px; text-align: right; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); backdrop-filter: blur(8px); }
        #log-panel { bottom: 30px; left: 30px; width: 350px; font-size: 13px; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; max-height: 200px; overflow-y: auto; }
        h1 { margin: 0; font-size: 1.2rem; letter-spacing: 2px; color: #ffd700; margin-bottom: 5px; }
        #turn-txt { font-size: 2rem; font-weight: 800; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 20px; font-weight: bold; background: rgba(0,0,0,0.8); padding: 30px 50px; border-radius: 10px; z-index: 999; }
    </style>
</head>
<body>

<div id="loading">正在雕刻 3D 棋子模型...</div>

<div id="ui" style="display:none;">
    <div id="status-panel" class="hud">
        <h1>REAL 3D CHESS</h1>
        <div id="turn-txt">YOUR TURN</div>
    </div>
    <div id="log-panel" class="hud">
        <div id="move-log">System: Geometry Engine Loaded.</div>
    </div>
</div>

<script>
let scene, camera, renderer, controls, raycaster, mouse, clock;
let game = new Chess();
let tilesMap = {}, piecesMap = {};
let selectedSquare = null, isProcessing = false;
let grassMat;

const CHESS_NAMES = { k: 'KING', q: 'QUEEN', r: 'ROOK', b: 'BISHOP', n: 'KNIGHT', p: 'PAWN' };

function init() {
    clock = new THREE.Clock();
    scene = new THREE.Scene();
    
    // 1. 清晰的大氣 (修復雲遮擋問題)
    scene.fog = new THREE.FogExp2(0xddeeff, 0.002); 
    scene.background = new THREE.Color(0x88ccee);

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 20, 25);

    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 2.1;
    controls.minDistance = 5; controls.maxDistance = 100;

    setupLighting();
    
    // 延遲執行以避免卡頓
    setTimeout(() => {
        createSharpTerrain();
        createVegetation();
        createHighClouds(); // 新的高空雲層
        createBoard();
        syncPieces();
        document.getElementById('loading').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
    }, 100);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    window.addEventListener('click', onMouseClick);
    window.addEventListener('resize', onResize);

    animate();
}

function setupLighting() {
    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);

    const sunLight = new THREE.DirectionalLight(0xfffaed, 1.5);
    sunLight.position.set(100, 150, -80);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.set(4096, 4096);
    sunLight.shadow.bias = -0.0005;
    const d = 150;
    sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d;
    sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
    scene.add(sunLight);

    const sky = new THREE.Sky(); sky.scale.setScalar(450000); scene.add(sky);
    const uniforms = sky.material.uniforms;
    uniforms['turbidity'].value = 10; uniforms['rayleigh'].value = 2;
    uniforms['mieCoefficient'].value = 0.005; uniforms['mieDirectionalG'].value = 0.8;
    uniforms['sunPosition'].value.copy(sunLight.position);
}

// --- 2. 真 3D 棋子雕刻工廠 (Procedural Modeling) ---

// 材質定義
const whiteMat = new THREE.MeshStandardMaterial({ 
    color: 0xffffff, roughness: 0.1, metalness: 0.1, // 陶瓷白
    emissive: 0x111111 
});
const blackMat = new THREE.MeshStandardMaterial({ 
    color: 0x222222, roughness: 0.3, metalness: 0.8, // 黑金屬
    emissive: 0x000000
});
const neonBlue = new THREE.MeshStandardMaterial({ color: 0x00e5ff, emissive: 0x00e5ff, emissiveIntensity: 2 });
const neonRed = new THREE.MeshStandardMaterial({ color: 0xff0055, emissive: 0xff0055, emissiveIntensity: 2 });

function getPieceMaterial(color) {
    return color === 'w' ? whiteMat : blackMat;
}

// 生成棋子幾何體
function createMeshPiece(type, color) {
    const group = new THREE.Group();
    const mat = getPieceMaterial(color);
    const glowMat = color === 'w' ? neonBlue : neonRed;

    // 通用底座
    const baseGeo = new THREE.CylinderGeometry(0.4, 0.45, 0.2, 32);
    const base = new THREE.Mesh(baseGeo, mat);
    base.position.y = 0.1;
    base.castShadow = true; base.receiveShadow = true;
    group.add(base);

    if (type === 'p') { // 兵 Pawn
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.35, 0.6, 16), mat);
        body.position.y = 0.5; body.castShadow = true;
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 32, 32), mat);
        head.position.y = 0.95; head.castShadow = true;
        group.add(body, head);
    } 
    else if (type === 'r') { // 城堡 Rook
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.8, 32), mat);
        body.position.y = 0.6; body.castShadow = true;
        // 塔頂
        const top = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.3, 32), mat);
        top.position.y = 1.1; top.castShadow = true;
        // 內部發光環
        const ring = new THREE.Mesh(new THREE.TorusGeometry(0.2, 0.05, 16, 32), glowMat);
        ring.position.y = 1.25; ring.rotation.x = Math.PI/2;
        group.add(body, top, ring);
    }
    else if (type === 'b') { // 主教 Bishop
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.35, 1.0, 16), mat);
        body.position.y = 0.7; body.castShadow = true;
        const hat = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.25, 0.5, 16), mat);
        hat.position.y = 1.4; hat.castShadow = true;
        const top = new THREE.Mesh(new THREE.SphereGeometry(0.08), glowMat);
        top.position.y = 1.7;
        group.add(body, hat, top);
    }
    else if (type === 'n') { // 騎士 Knight (馬) - 用幾何體拼湊馬頭
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, 0.6, 16), mat);
        body.position.y = 0.5; body.castShadow = true;
        
        // 馬頭 (長方體 + 旋轉)
        const headGeo = new THREE.BoxGeometry(0.3, 0.6, 0.2);
        const head = new THREE.Mesh(headGeo, mat);
        head.position.set(0, 1.0, 0.1);
        head.rotation.x = -Math.PI / 6; head.castShadow = true;
        
        // 馬嘴
        const snout = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.2, 0.3), mat);
        snout.position.set(0, 1.1, 0.35); snout.castShadow = true;

        // 鬃毛 (發光)
        const mane = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.05), glowMat);
        mane.position.set(0, 1.1, -0.15);
        mane.rotation.x = -Math.PI / 6;

        group.add(body, head, snout, mane);
        
        // 確保黑方馬頭朝向正確
        if (color === 'b') group.rotation.y = Math.PI;
    }
    else if (type === 'q') { // 皇后 Queen
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 1.4, 32), mat);
        body.position.y = 0.9; body.castShadow = true;
        // 皇冠
        const crown = new THREE.Mesh(new THREE.DodecahedronGeometry(0.3), mat);
        crown.position.y = 1.7; crown.castShadow = true;
        const gem = new THREE.Mesh(new THREE.SphereGeometry(0.15), glowMat);
        gem.position.y = 1.7; 
        group.add(body, crown, gem);
    }
    else if (type === 'k') { // 國王 King
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.45, 1.6, 32), mat);
        body.position.y = 1.0; body.castShadow = true;
        // 十字架 (用兩個長方體)
        const v = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.1), glowMat);
        v.position.y = 1.95;
        const h = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 0.1), glowMat);
        h.position.y = 2.0;
        group.add(body, v, h);
    }

    return group;
}

// --- 3. 雲層重製：高空安全雲 (High Clouds) ---
function createHighClouds() {
    // 使用簡單的幾何體，但放在極高空，絕對不遮擋視線
    const cloudGeo = new THREE.BoxGeometry(20, 2, 10);
    const cloudMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffff, transparent: true, opacity: 0.4, 
        fog: false // 讓它在遠處也清晰
    });

    const cloudGroup = new THREE.Group();
    for(let i=0; i<30; i++) {
        const c = new THREE.Mesh(cloudGeo, cloudMat);
        const x = (Math.random()-0.5) * 600;
        const z = (Math.random()-0.5) * 600;
        const y = 80 + Math.random() * 40; // 高度 > 80，絕對安全
        c.position.set(x, y, z);
        c.scale.set(1 + Math.random(), 1, 1 + Math.random());
        cloudGroup.add(c);
    }
    scene.add(cloudGroup);
    // 讓雲緩慢移動
    new TWEEN.Tween(cloudGroup.position).to({x: 50}, 60000).repeat(Infinity).yoyo(true).start();
}

// --- 4. 地形與植被 ---
function createSharpTerrain() {
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshStandardMaterial({ color: 0x3d4c35, roughness: 0.8 }));
    ground.rotation.x = -Math.PI / 2; ground.position.y = -0.5; ground.receiveShadow = true; scene.add(ground);

    // 遠山
    const mGeo = new THREE.ConeGeometry(80, 200, 4, 1, true);
    const mMat = new THREE.MeshStandardMaterial({ color: 0x5a6a6a, flatShading: true });
    for(let i=0; i<10; i++) {
        const m = new THREE.Mesh(mGeo, mMat);
        const r = 300 + Math.random()*200;
        const a = Math.random()*Math.PI*2;
        m.position.set(Math.cos(a)*r, -20, Math.sin(a)*r);
        m.scale.set(1+Math.random(), 1, 1+Math.random());
        scene.add(m);
    }
}

function createVegetation() {
    // 樹木 (團塊狀樹葉)
    const tGroup = new THREE.Group();
    const tMat = new THREE.MeshStandardMaterial({ color: 0x4a3c31 });
    const lMat = new THREE.MeshStandardMaterial({ color: 0x2d4c1e, flatShading: true });
    
    for(let i=0; i<120; i++){
        const tree = new THREE.Group();
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.5,2,6), tMat);
        trunk.position.y=1; trunk.castShadow=true; tree.add(trunk);
        for(let j=0; j<6; j++){
            const l = new THREE.Mesh(new THREE.DodecahedronGeometry(1.2), lMat);
            l.position.set((Math.random()-0.5)*1.5, 2.5+Math.random()*1.5, (Math.random()-0.5)*1.5);
            l.castShadow=true; tree.add(l);
        }
        const r = 50 + Math.random()*100;
        const a = Math.random()*Math.PI*2;
        tree.position.set(Math.cos(a)*r, 0, Math.sin(a)*r);
        tGroup.add(tree);
    }
    scene.add(tGroup);
    
    // 草
    const bGeo = new THREE.PlaneGeometry(0.1, 0.5); bGeo.translate(0,0.25,0);
    grassMat = new THREE.MeshStandardMaterial({ color: 0x557733, side: THREE.DoubleSide });
    grassMat.onBeforeCompile = s => {
        s.uniforms.time={value:0}; s.vertexShader=`uniform float time;\n`+s.vertexShader;
        s.vertexShader=s.vertexShader.replace(`#include <begin_vertex>`, `vec3 transformed=vec3(position); float w=sin(time+position.x)*0.1*position.y; transformed.x+=w; #include <begin_vertex>`);
        grassMat.userData.shader=s;
    };
    const iGrass = new THREE.InstancedMesh(bGeo, grassMat, 8000);
    const dum = new THREE.Object3D();
    for(let i=0;i<8000;i++){
        const r=8+Math.random()*90, a=Math.random()*Math.PI*2;
        dum.position.set(Math.cos(a)*r, -0.1, Math.sin(a)*r);
        dum.rotation.y=Math.random()*Math.PI; dum.updateMatrix();
        iGrass.setMatrixAt(i, dum.matrix);
    }
    iGrass.receiveShadow=true; scene.add(iGrass);
}

// --- 棋盤 ---
function createBoard(){
    const b = new THREE.Mesh(new THREE.BoxGeometry(8.4, 0.4, 8.4), new THREE.MeshStandardMaterial({color:0x222222}));
    b.position.y=-0.2; b.receiveShadow=true; scene.add(b);
    for(let r=0;r<8;r++)for(let c=0;c<8;c++){
        const n=String.fromCharCode(97+c)+(r+1), isW=(r+c)%2!==0;
        const t=new THREE.Mesh(new THREE.BoxGeometry(1,0.2,1), new THREE.MeshStandardMaterial({
            color:isW?0xeeddaa:0x333333, roughness:0.2, metalness:0.3
        }));
        t.position.set(c-3.5,0,3.5-r); t.userData={square:n,isTile:true}; t.receiveShadow=true; scene.add(t); tilesMap[n]=t;
    }
}

function syncPieces(){
    for(let sq in piecesMap) scene.remove(piecesMap[sq]); piecesMap={}; const b=game.board();
    for(let r=0;r<8;r++)for(let c=0;c<8;c++){
        const p=b[r][c];
        if(p){
            const sq=String.fromCharCode(97+c)+(8-r);
            const mesh=createMeshPiece(p.type, p.color);
            mesh.position.set(c-3.5, 0, r-3.5);
            scene.add(mesh);
            piecesMap[sq]=mesh;
        }
    }
}

// --- 交互 ---
function onMouseClick(e){if(isProcessing)return;mouse.x=(e.clientX/window.innerWidth)*2-1;mouse.y=-(e.clientY/window.innerHeight)*2+1;raycaster.setFromCamera(mouse,camera);const i=raycaster.intersectObjects(Object.values(tilesMap));if(i.length>0)handleInteraction(i[0].object.userData.square);}
function handleInteraction(sq){const p=game.get(sq);if(!selectedSquare){if(p&&p.color==='w'&&game.turn()==='w')selectSquare(sq);}else{if(p&&p.color==='w'){selectSquare(sq);return;}const m=game.move({from:selectedSquare,to:sq,promotion:'q'});if(m)animateMove(m);else{clearHighlights();selectedSquare=null;}}}
function selectSquare(sq){clearHighlights();selectedSquare=sq;tilesMap[sq].material.emissive.setHex(0xffff00);tilesMap[sq].material.emissiveIntensity=0.5;game.moves({square:sq,verbose:true}).forEach(m=>{tilesMap[m.to].material.emissive.setHex(m.captured?0xff0000:0x00ff00);tilesMap[m.to].material.emissiveIntensity=0.5;});}
function clearHighlights(){for(let sq in tilesMap){tilesMap[sq].material.emissive.setHex(0x000000);tilesMap[sq].material.emissiveIntensity=0;}}
function animateMove(m){isProcessing=true;clearHighlights();const s=piecesMap[m.from],e=tilesMap[m.to].position.clone();
if(m.captured&&piecesMap[m.to])scene.remove(piecesMap[m.to]);
new TWEEN.Tween(s.position).to(e,500).easing(TWEEN.Easing.Quadratic.Out).onComplete(()=>{syncPieces();updateStatus();if(game.game_over())return;if(game.turn()==='b')setTimeout(makeRandomAI,500);else isProcessing=false;}).start();}
function makeRandomAI(){const ms=game.moves();if(ms.length===0)return;game.move(ms[Math.floor(Math.random()*ms.length)]);syncPieces();updateStatus();isProcessing=false;}
function updateStatus(){const t=document.getElementById('turn-txt');t.innerText=game.turn()==='w'?"YOUR TURN":"AI TURN";t.style.color=game.turn()==='w'?"#00e5ff":"#ff0055";log(`Move: ${game.history().pop()}`);}
function log(m){document.getElementById('move-log').innerText+=`\n> ${m}`;}
function onResize(){camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);}

function animate(){
    requestAnimationFrame(animate); const t=clock.getElapsedTime(); TWEEN.update(); controls.update();
    if(grassMat&&grassMat.userData.shader)grassMat.userData.shader.uniforms.time.value=t;
    renderer.render(scene,camera);
}
init();
</script>
</body>
</html>
