<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>線性聯立方程與交點觀察器</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <style>
        body { font-family: 'Segoe UI', system-ui, sans-serif; margin: 0; display: flex; height: 100vh; background: #f8f9fa; overflow: hidden; }
        
        /* 左側控制面板 */
        .sidebar { width: 380px; background: white; border-right: 1px solid #dee2e6; display: flex; flex-direction: column; box-shadow: 2px 0 10px rgba(0,0,0,0.05); z-index: 10; }
        .header { padding: 20px; border-bottom: 1px solid #eee; background: #2c3e50; color: white; }
        .scroll-area { flex-grow: 1; overflow-y: auto; padding: 20px; }
        
        .input-card { background: #fdfdfd; border: 1px solid #e0e0e0; padding: 15px; margin-bottom: 15px; border-radius: 8px; border-left: 6px solid #4a90e2; }
        .inputs { display: flex; align-items: center; gap: 6px; margin-top: 10px; flex-wrap: wrap; }
        input { width: 50px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; text-align: center; font-size: 14px; }
        select { padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-size: 14px; }
        
        .footer { padding: 20px; border-top: 1px solid #eee; background: #fff; }
        button { width: 100%; padding: 12px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; margin-bottom: 10px; transition: 0.2s; font-size: 15px; }
        .btn-add { background: #e3f2fd; color: #1976d2; }
        .btn-draw { background: #1976d2; color: white; }
        .btn-reset { background: #f1f3f4; color: #5f6368; }

        /* 右側圖表區 */
        .main-view { flex-grow: 1; padding: 20px; display: flex; flex-direction: column; position: relative; }
        .chart-wrapper { background: white; flex-grow: 1; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); padding: 15px; position: relative; touch-action: none; }
        canvas { width: 100% !important; height: 100% !important; }

        /* 手機版適配 */
        @media (max-width: 768px) {
            body { flex-direction: column; }
            .sidebar { width: 100%; max-height: 45%; border-right: none; border-bottom: 1px solid #dee2e6; }
            .main-view { padding: 10px; }
        }
    </style>
</head>
<body>

<div class="sidebar">
    <div class="header">
        <h2 style="margin:0; font-size: 18px;">聯立方程運算引擎</h2>
        <p style="margin:5px 0 0 0; opacity:0.8; font-size: 12px;">已開啟中心點鎖定縮放與自動交點</p>
    </div>
    
    <div class="scroll-area" id="equation-list">
        <div class="input-card" style="border-left-color: hsl(0, 70%, 50%);">
            <strong>L1</strong>
            <div class="inputs">
                <input type="number" class="a-val" value="2"> x + 
                <input type="number" class="b-val" value="1"> y + 
                <input type="number" class="c-val" value="-6">
                <select class="op-val"><option value="=">=</option><option value=">=">&ge;</option><option value="<=">&le;</option></select> 0
            </div>
        </div>
        <div class="input-card" style="border-left-color: hsl(137.5, 70%, 50%);">
            <strong>L2</strong>
            <div class="inputs">
                <input type="number" class="a-val" value="1"> x + 
                <input type="number" class="b-val" value="-1"> y + 
                <input type="number" class="c-val" value="0">
                <select class="op-val"><option value="=">=</option><option value=">=">&ge;</option><option value="<=">&le;</option></select> 0
            </div>
        </div>
    </div>

    <div class="footer">
        <button class="btn-add" onclick="addNewLine()">＋ 新增方程式</button>
        <button class="btn-draw" onclick="draw()">更新並解聯立 (Enter)</button>
        <button class="btn-reset" onclick="resetZoom()">回歸初始比例</button>
    </div>
</div>

<div class="main-view">
    <div class="chart-wrapper">
        <canvas id="mathChart"></canvas>
    </div>
</div>

<script>
    let myChart = null;

    function addNewLine() {
        const list = document.getElementById('equation-list');
        const n = list.children.length + 1;
        const div = document.createElement('div');
        div.className = 'input-card';
        div.style.borderLeftColor = `hsl(${n * 137.5}, 70%, 50%)`;
        div.innerHTML = `<strong>L${n}</strong>
            <div class="inputs">
                <input type="number" class="a-val" value="1"> x + 
                <input type="number" class="b-val" value="1"> y + 
                <input type="number" class="c-val" value="${-n * 2}">
                <select class="op-val"><option value="=">=</option><option value=">=">&ge;</option><option value="<=">&le;</option></select> 0
            </div>`;
        list.appendChild(div);
    }

    function resetZoom() { if (myChart) myChart.resetZoom(); }

    // 克拉瑪公式解二元一次聯立方程式
    function findIntersection(l1, l2) {
        const det = l1.a * l2.b - l2.a * l1.b;
        if (Math.abs(det) < 1e-10) return null; // 行列式為 0 代表平行或重合
        
        const dx = (-l1.c) * l2.b - (-l2.c) * l1.b;
        const dy = l1.a * (-l2.c) - l2.a * (-l1.c);
        
        return { 
            x: Math.round((dx / det) * 100) / 100, // 四捨五入到小數點第二位
            y: Math.round((dy / det) * 100) / 100 
        };
    }

    function draw() {
        const as = document.querySelectorAll('.a-val'), bs = document.querySelectorAll('.b-val');
        const cs = document.querySelectorAll('.c-val'), ops = document.querySelectorAll('.op-val');
        const datasets = [];
        const lines = [];

        // 收集所有方程式並繪製線條
        as.forEach((_, i) => {
            const a = parseFloat(as[i].value) || 0, b = parseFloat(bs[i].value) || 0, c = parseFloat(cs[i].value) || 0;
            const op = ops[i].value;
            
            if (a === 0 && b === 0) return; // 無效方程式
            if (op === '=') lines.push({ a, b, c, name: `L${i+1}` }); // 只計算等式的交點

            let points = [], fillType = false;
            const hue = (i * 137.5) % 360;

            if (b !== 0) {
                // 擴大繪圖範圍以適應縮放
                for (let x = -500; x <= 500; x += 10) points.push({ x: x, y: (-a * x - c) / b });
                if (op !== '=') {
                    const isGreater = op.includes('>');
                    fillType = (b > 0) ? (isGreater ? 'end' : 'origin') : (isGreater ? 'origin' : 'end');
                }
            } else if (a !== 0) {
                const posX = -c / a;
                points.push({ x: posX, y: -500 }, { x: posX, y: 500 });
            }

            datasets.push({
                label: `L${i+1}`,
                data: points,
                borderColor: `hsl(${hue}, 70%, 50%)`,
                backgroundColor: `hsla(${hue}, 70%, 50%, 0.15)`,
                fill: fillType,
                showLine: true,
                pointRadius: 0,
                borderWidth: 2,
                borderDash: (op === '>' || op === '<') ? [5, 5] : []
            });
        });

        // 兩兩計算交點
        const intersections = [];
        for (let i = 0; i < lines.length; i++) {
            for (let j = i + 1; j < lines.length; j++) {
                const point = findIntersection(lines[i], lines[j]);
                if (point) {
                    intersections.push({
                        x: point.x,
                        y: point.y,
                        info: `${lines[i].name} 與 ${lines[j].name} 交點`
                    });
                }
            }
        }

        // 將交點作為獨立的資料集繪製
        if (intersections.length > 0) {
            datasets.push({
                label: '交點 (Intersection)',
                data: intersections,
                backgroundColor: '#e74c3c',
                borderColor: '#fff',
                borderWidth: 2,
                pointRadius: 6,
                pointHoverRadius: 9,
                showLine: false
            });
        }

        const ctx = document.getElementById('mathChart').getContext('2d');
        if (myChart) myChart.destroy();
        
        myChart = new Chart(ctx, {
            type: 'scatter',
            data: { datasets: datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { type: 'linear', position: 'center', min: -15, max: 15, grid: { color: '#e0e0e0', lineWidth: 1 } },
                    y: { type: 'linear', position: 'center', min: -15, max: 15, grid: { color: '#e0e0e0', lineWidth: 1 } }
                },
                plugins: {
                    zoom: {
                        // 完全關閉平移功能
                        pan: { enabled: false },
                        zoom: { 
                            wheel: { enabled: true }, 
                            pinch: { enabled: true }, 
                            mode: 'xy',
                            // 強制縮放時保持 x, y 軸的上下限對稱，確保 (0,0) 永遠在正中間
                            onZoom: function({chart}) {
                                const maxScale = Math.max(Math.abs(chart.scales.x.min), Math.abs(chart.scales.x.max), Math.abs(chart.scales.y.min), Math.abs(chart.scales.y.max));
                                chart.options.scales.x.min = -maxScale;
                                chart.options.scales.x.max = maxScale;
                                chart.options.scales.y.min = -maxScale;
                                chart.options.scales.y.max = maxScale;
                                chart.update('none');
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                if (context.dataset.label === '交點 (Intersection)') {
                                    return `${context.raw.info}: (${context.raw.x}, ${context.raw.y})`;
                                }
                                return `(${context.raw.x.toFixed(1)}, ${context.raw.y.toFixed(1)})`;
                            }
                        }
                    },
                    legend: { position: 'top', labels: { filter: function(item) { return item.text !== '交點 (Intersection)'; } } }
                }
            }
        });
    }

    window.onload = draw;
    document.addEventListener('keydown', (e) => { if(e.key === 'Enter') draw(); });
</script>
</body>
</html>
