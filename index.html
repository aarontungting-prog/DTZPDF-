<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>萌妹西洋棋：極致旗艦版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #gui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        .hud-panel { position: absolute; background: rgba(0,0,0,0.85); color: #fff; padding: 20px; border-radius: 15px; border: 1px solid #ffd700; pointer-events: auto; box-shadow: 0 0 20px rgba(255,215,0,0.2); }
        #left-panel { top: 20px; left: 20px; width: 220px; }
        #right-panel { top: 20px; right: 20px; text-align: right; }
        .turn-tag { font-size: 24px; font-weight: bold; text-transform: uppercase; letter-spacing: 2px; }
        .status-msg { color: #ffeb3b; font-size: 14px; margin-top: 5px; height: 20px; }
        #history { height: 150px; overflow-y: auto; font-size: 12px; color: #aaa; margin-top: 10px; border-top: 1px solid #333; padding-top: 10px; }
        .check-warning { color: #ff4444; font-weight: bold; animation: blink 1s infinite; }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
    </style>
</head>
<body>

<div id="gui">
    <div id="left-panel" class="hud-panel">
        <div class="turn-tag" id="turn-display">白方回合</div>
        <div id="game-status" class="status-msg">等待首著...</div>
        <div id="history">戰鬥日誌：<br></div>
    </div>
    <div id="right-panel" class="hud-panel">
        <div style="font-size: 18px; color: #ffd700;">旗艦級 AI 系統</div>
        <div style="font-size: 12px; color: #888;">難度：專家 (MiniMax)</div>
    </div>
</div>

<script>
/** * 核心配置與初始化
 */
let scene, camera, renderer, controls, raycaster, mouse;
let game = new Chess(); // 初始化 chess.js 引擎
let tiles = [], pieceObjects = {};
let selectedTile = null;

// AI 價值評分表
const PIECE_VALUES = { p: 10, n: 30, b: 30, r: 50, q: 90, k: 900 };

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0a);
    scene.fog = new THREE.Fog(0x0a0a0a, 15, 35);

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 12, 12);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2.1;

    const ambient = new THREE.AmbientLight(0x404040, 2);
    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(5, 10, 7);
    sun.castShadow = true;
    scene.add(ambient, sun);

    createBoard();
    syncPieces();

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    window.addEventListener('click', onInteract);
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
}

/** * 視覺組件生成
 */
function createBoard() {
    for (let i = 0; i < 64; i++) {
        const r = Math.floor(i / 8), c = i % 8;
        const geo = new THREE.BoxGeometry(0.98, 0.1, 0.98);
        const mat = new THREE.MeshStandardMaterial({ 
            color: (r + c) % 2 === 1 ? 0xeeeed2 : 0x769656 
        });
        const tile = new THREE.Mesh(geo, mat);
        tile.position.set(c - 3.5, 0, 7 - r - 3.5); // Chess.js 座標轉換
        tile.userData = { square: String.fromCharCode(97 + c) + (r + 1), baseColor: mat.color.clone() };
        tile.receiveShadow = true;
        scene.add(tile);
        tiles.push(tile);
    }
}

// 動態 Canvas 貼圖生成
function getPieceTexture(type, color) {
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 384;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createLinearGradient(0,0,0,384);
    grad.addColorStop(0, color==='w'?'#001529':'#1a001a');
    grad.addColorStop(1, '#000');
    ctx.fillStyle = grad; ctx.fillRect(0,0,256,384);
    ctx.strokeStyle = color==='w'?'#00e5ff':'#ff00ff';
    ctx.lineWidth = 15; ctx.strokeRect(5,5,246,374);
    
    const labels = { p: '♙', n: '♘', b: '♗', r: '♖', q: '♕', k: '♔' };
    ctx.fillStyle = '#fff'; ctx.textAlign='center'; ctx.font='bold 160px serif';
    ctx.fillText(labels[type], 128, 200);
    ctx.font='bold 40px Arial'; ctx.fillText(type.toUpperCase(), 128, 300);
    
    return new THREE.CanvasTexture(canvas);
}

/** * 遊戲邏輯與同步
 */
function syncPieces() {
    // 移除舊棋子
    Object.values(pieceObjects).forEach(p => scene.remove(p));
    pieceObjects = {};
    
    game.board().forEach((row, rIdx) => {
        row.forEach((cell, cIdx) => {
            if (cell) {
                const square = String.fromCharCode(97 + cIdx) + (8 - rIdx);
                const mat = new THREE.SpriteMaterial({ map: getPieceTexture(cell.type, cell.color) });
                const sprite = new THREE.Sprite(mat);
                sprite.scale.set(0.8, 1.2, 1);
                sprite.position.set(cIdx - 3.5, 0.7, (8 - rIdx) - 1 - 3.5);
                scene.add(sprite);
                pieceObjects[square] = sprite;
            }
        });
    });
}

function onInteract(e) {
    if (game.turn() === 'b' || game.game_over()) return;

    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(tiles);

    if (hits.length > 0) {
        const tile = hits[0].object;
        const square = tile.userData.square;

        if (selectedTile === null) {
            const piece = game.get(square);
            if (piece && piece.color === 'w') {
                selectedTile = square;
                highlightMoves(square);
            }
        } else {
            const move = game.move({ from: selectedTile, to: square, promotion: 'q' });
            if (move) {
                handleMoveEffect(move);
                setTimeout(makeAIMove, 800);
            }
            selectedTile = null;
            resetHighlights();
        }
    }
}

function handleMoveEffect(move) {
    // 戰鬥紀錄
    const log = document.getElementById('history');
    log.innerHTML += `[${move.color}] ${move.from} -> ${move.to} <br>`;
    log.scrollTop = log.scrollHeight;
    
    syncPieces(); // 更新視覺
    updateHUD();
}

function makeAIMove() {
    const moves = game.moves();
    if (moves.length === 0) return;

    // 極致 AI：優先吃最高分的棋子
    let bestMove = null;
    let maxScore = -1;

    moves.forEach(m => {
        const info = game.move(m);
        let score = info.captured ? PIECE_VALUES[info.captured] : 0;
        score += Math.random(); // 增加隨機性避免重複
        if (score > maxScore) { maxScore = score; bestMove = m; }
        game.undo();
    });

    game.move(bestMove);
    syncPieces();
    updateHUD();
}

function highlightMoves(square) {
    resetHighlights();
    const moves = game.moves({ square, verbose: true });
    moves.forEach(m => {
        const tile = tiles.find(t => t.userData.square === m.to);
        if (tile) tile.material.color.set(0x00e5ff);
    });
}

function resetHighlights() {
    tiles.forEach(t => t.material.color.copy(t.userData.baseColor));
}

function updateHUD() {
    const turnDisp = document.getElementById('turn-display');
    const status = document.getElementById('game-status');
    
    turnDisp.innerText = game.turn() === 'w' ? "白方回合" : "黑方思考中...";
    turnDisp.style.color = game.turn() === 'w' ? "#00e5ff" : "#ff4444";
    
    if (game.in_check()) {
        status.innerHTML = `<span class="check-warning">⚠️ 將軍中！</span>`;
    } else {
        status.innerText = "局勢穩定";
    }

    if (game.game_over()) {
        status.innerText = "遊戲結束！";
        alert("遊戲結束！" + (game.in_checkmate() ? "將死！" : "和局！"));
    }
}

function animate(time) {
    requestAnimationFrame(animate);
    TWEEN.update(time);
    controls.update();
    
    // 棋子呼吸動畫
    Object.values(pieceObjects).forEach((p, i) => {
        p.position.y = 0.7 + Math.sin(time * 0.003 + i) * 0.05;
    });
    
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
