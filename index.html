<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>霓虹西洋棋：光追級寫實重製版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/objects/Sky.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #88ccee; font-family: 'Segoe UI', sans-serif; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        
        /* UI 改為現代簡潔風格，高對比度 */
        .hud { position: absolute; color: #fff; text-shadow: 0 1px 3px rgba(0,0,0,0.8); pointer-events: auto; }
        #status-panel { top: 30px; right: 30px; text-align: right; background: rgba(0,0,0,0.4); padding: 15px; border-radius: 8px; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.2); }
        #log-panel { bottom: 30px; left: 30px; width: 320px; font-size: 13px; background: linear-gradient(to top, rgba(0,0,0,0.6), transparent); padding: 20px; border-radius: 8px; }
        
        h1 { margin: 0; font-size: 1.1rem; text-transform: uppercase; letter-spacing: 2px; color: #ffd700; border-bottom: 1px solid rgba(255,255,255,0.3); padding-bottom: 5px; margin-bottom: 5px; }
        #turn-txt { font-size: 1.8rem; font-weight: 800; }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 16px; font-weight: bold; background: rgba(0,0,0,0.7); padding: 20px 40px; border-radius: 30px; z-index: 999; }
    </style>
</head>
<body>

<div id="loading">正在生成高面數植被與地形...</div>

<div id="ui" style="display:none;">
    <div id="status-panel" class="hud">
        <h1>Golden Hour Chess</h1>
        <div id="turn-txt">YOUR TURN</div>
    </div>
    <div id="log-panel" class="hud">
        <div id="move-log">Render Pipeline: Ray-Tracing Style<br>Time: 06:30 AM</div>
    </div>
</div>

<script>
// --- 核心變數 ---
let scene, camera, renderer, controls, raycaster, mouse, clock;
let game = new Chess();
let tilesMap = {}, piecesMap = {};
let selectedSquare = null, isProcessing = false;
let grassMat;

const CHESS_NAMES = { k: 'KING', q: 'QUEEN', r: 'ROOK', b: 'BISHOP', n: 'KNIGHT', p: 'PAWN' };

function init() {
    clock = new THREE.Clock();
    scene = new THREE.Scene();
    
    // 1. 真實大氣霧 (不再是死黑或死藍，而是帶有陽光散射的暖霧)
    scene.fog = new THREE.FogExp2(0xe6e8dc, 0.0035); 
    scene.background = new THREE.Color(0x88ccee);

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 3000);
    camera.position.set(0, 20, 28);

    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 高品質軟陰影
    renderer.toneMapping = THREE.ACESFilmicToneMapping; // 電影級色調
    renderer.toneMappingExposure = 1.1;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 2.05;
    controls.minDistance = 10; controls.maxDistance = 150;

    setupLighting();
    
    // 延遲生成以避免卡頓
    setTimeout(() => {
        createTerrain();
        createRealisticVegetation();
        createClouds();
        createBoard();
        syncPieces();
        document.getElementById('loading').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
    }, 100);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    window.addEventListener('click', onMouseClick);
    window.addEventListener('resize', onResize);

    animate();
}

function setupLighting() {
    // 2. 黃金時刻光照設置
    
    // 環境光：天空的漫反射 (偏藍，模擬天光)
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemiLight.position.set(0, 200, 0);
    scene.add(hemiLight);

    // 主光源：太陽 (偏暖橘，低角度，拉長陰影)
    const sunLight = new THREE.DirectionalLight(0xffdfba, 1.8);
    sunLight.position.set(100, 50, -100); // 側面低角度照射
    sunLight.castShadow = true;
    
    // 極致陰影配置
    sunLight.shadow.mapSize.width = 4096;
    sunLight.shadow.mapSize.height = 4096;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 500;
    const d = 150;
    sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d;
    sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
    sunLight.shadow.bias = -0.0005; // 減少陰影條紋
    scene.add(sunLight);

    // Sky Shader：模擬真實大氣散射
    const sky = new THREE.Sky();
    sky.scale.setScalar(450000);
    scene.add(sky);
    const uniforms = sky.material.uniforms;
    uniforms['turbidity'].value = 10;
    uniforms['rayleigh'].value = 3;
    uniforms['mieCoefficient'].value = 0.005;
    uniforms['mieDirectionalG'].value = 0.7;
    uniforms['sunPosition'].value.copy(sunLight.position);

    // 可見的太陽本體
    const sunGeo = new THREE.SphereGeometry(20, 32, 32);
    const sunMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
    const sunSphere = new THREE.Mesh(sunGeo, sunMat);
    sunSphere.position.copy(sunLight.position).normalize().multiplyScalar(1000);
    scene.add(sunSphere);
}

// --- 3. 真實植被生成器 (模仿你的連結) ---
function createRealisticVegetation() {
    
    // A. 樹木 (Deciduous Tree - 闊葉樹風格)
    // 我們不再用圓錐，改用"團塊" (Clumps) 來模擬樹冠
    const treeGroup = new THREE.Group();
    
    // 樹幹材質 (粗糙樹皮)
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 1.0 });
    // 樹葉材質 (透光感)
    const leafMat = new THREE.MeshStandardMaterial({ color: 0x4a6741, roughness: 0.8, flatShading: true });

    // 樹木幾何體原型 (合併多個球體，模擬樹叢)
    // 為了效能，我們手動拼湊一棵高細節樹，然後實例化它
    
    // 生成一棵樹的函數
    const createTreeMesh = (x, z, scale) => {
        const tree = new THREE.Group();
        
        // 樹幹
        const trunkGeo = new THREE.CylinderGeometry(0.4 * scale, 0.6 * scale, 3 * scale, 7);
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 1.5 * scale;
        trunk.castShadow = true; trunk.receiveShadow = true;
        tree.add(trunk);

        // 樹冠：由 5-7 個變形的球體組成，模擬樹葉團
        for(let i=0; i<7; i++) {
            const size = (1.0 + Math.random()) * scale;
            const leafGeo = new THREE.DodecahedronGeometry(size, 0); // 低多邊形球體
            const leaf = new THREE.Mesh(leafGeo, leafMat);
            
            // 隨機分佈在樹幹頂端周圍
            leaf.position.set(
                (Math.random()-0.5) * 2 * scale,
                (2.5 * scale) + Math.random() * 2 * scale,
                (Math.random()-0.5) * 2 * scale
            );
            leaf.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            leaf.castShadow = true; leaf.receiveShadow = true;
            tree.add(leaf);
        }
        
        tree.position.set(x, 0, z);
        return tree;
    };

    // 種植 150 棵樹
    for (let i = 0; i < 150; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 40 + Math.random() * 120; // 圍繞棋盤
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const scale = 1.0 + Math.random() * 0.8;
        
        const tree = createTreeMesh(x, z, scale);
        treeGroup.add(tree);
    }
    scene.add(treeGroup);

    // B. 茂密草地 (Instanced Mesh with Wind)
    const bladeGeo = new THREE.PlaneGeometry(0.15, 0.8); bladeGeo.translate(0, 0.4, 0);
    // 草的顏色更真實：稍微帶黃的綠色
    grassMat = new THREE.MeshStandardMaterial({ color: 0x556b2f, side: THREE.DoubleSide });
    
    grassMat.onBeforeCompile = (shader) => {
        shader.uniforms.time = { value: 0 };
        shader.vertexShader = `uniform float time;\n` + shader.vertexShader;
        shader.vertexShader = shader.vertexShader.replace(`#include <begin_vertex>`, 
        `vec3 transformed = vec3(position);
         float wave = sin(time * 1.0 + position.x * 0.5 + position.z * 0.5) * 0.15 * position.y;
         transformed.x += wave; 
         transformed.z += sin(time * 1.5 + position.x * 0.3) * 0.1 * position.y;
         #include <begin_vertex>`);
        grassMat.userData.shader = shader;
    };

    const grassCount = 10000;
    const instGrass = new THREE.InstancedMesh(bladeGeo, grassMat, grassCount);
    const dummy = new THREE.Object3D();
    for (let i = 0; i < grassCount; i++) {
        const r = 8 + Math.random() * 90;
        const theta = Math.random() * Math.PI * 2;
        dummy.position.set(Math.cos(theta)*r, -0.1, Math.sin(theta)*r);
        dummy.rotation.y = Math.random() * Math.PI;
        dummy.scale.setScalar(0.7 + Math.random() * 0.8);
        dummy.updateMatrix();
        instGrass.setMatrixAt(i, dummy.matrix);
    }
    instGrass.receiveShadow = true;
    scene.add(instGrass);
}

// --- 4. 真實地形與雲 ---
function createTerrain() {
    // 地面：不再是平面，而是有起伏的
    const groundGeo = new THREE.PlaneGeometry(500, 500, 128, 128);
    groundGeo.rotateX(-Math.PI / 2);
    
    // 簡單的高度偏移
    const pos = groundGeo.attributes.position;
    for(let i=0; i<pos.count; i++) {
        const x = pos.getX(i); const z = pos.getZ(i);
        const dist = Math.sqrt(x*x + z*z);
        if(dist > 15) { // 棋盤外圈起伏
            pos.setY(i, (Math.sin(x*0.1) + Math.cos(z*0.1)) * 1.5);
        }
    }
    groundGeo.computeVertexNormals();

    const groundMat = new THREE.MeshStandardMaterial({ 
        color: 0x3b4d28, // 泥土綠
        roughness: 1.0 
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.position.y = -0.2;
    ground.receiveShadow = true;
    scene.add(ground);

    // 遠山 (實體模型，不是Shader，更清晰)
    const mountainGroup = new THREE.Group();
    const mMat = new THREE.MeshStandardMaterial({ color: 0x5a6e5a, flatShading: true }); // 遠山青色
    for(let i=0; i<8; i++) {
        const w = 50 + Math.random()*50;
        const h = 40 + Math.random()*60;
        const mGeo = new THREE.ConeGeometry(w, h, 4); // 四面山體
        const m = new THREE.Mesh(mGeo, mMat);
        const angle = Math.random() * Math.PI * 2;
        const dist = 200 + Math.random() * 100;
        m.position.set(Math.cos(angle)*dist, h/2 - 20, Math.sin(angle)*dist);
        m.rotation.y = Math.random() * Math.PI;
        m.scale.set(1 + Math.random(), 1, 1 + Math.random());
        mountainGroup.add(m);
    }
    scene.add(mountainGroup);
}

function createClouds() {
    // 雲：使用分散的半透明白色幾何體，模擬積雲
    const cloudGroup = new THREE.Group();
    const cloudGeo = new THREE.DodecahedronGeometry(10, 0);
    const cloudMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffff, transparent: true, opacity: 0.6, 
        depthWrite: false 
    });

    for(let i=0; i<20; i++) {
        const cluster = new THREE.Group();
        for(let j=0; j<5; j++) {
            const puff = new THREE.Mesh(cloudGeo, cloudMat);
            puff.position.set(Math.random()*15, Math.random()*5, Math.random()*15);
            puff.scale.setScalar(1 + Math.random());
            cluster.add(puff);
        }
        const angle = Math.random() * Math.PI * 2;
        const dist = 100 + Math.random() * 200;
        cluster.position.set(Math.cos(angle)*dist, 40 + Math.random()*30, Math.sin(angle)*dist);
        cloudGroup.add(cluster);
    }
    scene.add(cloudGroup);
    
    // 讓雲緩慢移動的動畫變數
    window.cloudGroup = cloudGroup;
}

// --- 5. 棋盤 (大理石質感) ---
function createBoard(){
    // 邊框
    const border = new THREE.Mesh(
        new THREE.BoxGeometry(8.4, 0.4, 8.4),
        new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2 })
    );
    border.position.y = -0.2; border.receiveShadow = true; scene.add(border);

    for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
            const n=String.fromCharCode(97+c)+(r+1);
            const geo=new THREE.BoxGeometry(1,0.2,1);
            const isW=(r+c)%2!==0;
            const mat=new THREE.MeshStandardMaterial({
                color: isW ? 0xfffff0 : 0x333333, // 象牙白 vs 深灰
                roughness: 0.1, // 像拋光石頭
                metalness: 0.1
            });
            const t=new THREE.Mesh(geo,mat);
            t.position.set(c-3.5,0,3.5-r); t.userData={square:n,isTile:true}; 
            t.receiveShadow=true; t.castShadow=true;
            scene.add(t); tilesMap[n]=t;
        }
    }
}

function createPieceSprite(t,c){
    // 使用 Canvas 繪製更精緻的圖標，帶有金屬質感光澤
    const cv=document.createElement('canvas');cv.width=256;cv.height=384;const cx=cv.getContext('2d');
    cx.clearRect(0,0,256,384);
    
    // 玻璃質感背景
    const grad=cx.createLinearGradient(0,0,256,384);
    if (c==='w') { grad.addColorStop(0,'rgba(200,240,255,0.8)'); grad.addColorStop(1,'rgba(0,100,200,0.4)'); }
    else { grad.addColorStop(0,'rgba(220,180,255,0.8)'); grad.addColorStop(1,'rgba(100,0,200,0.4)'); }
    
    cx.fillStyle=grad; cx.fillRect(20,20,216,344);
    cx.strokeStyle='rgba(255,255,255,0.8)'; cx.lineWidth=8; cx.strokeRect(20,20,216,344); // 白邊框

    const s={k:'♔',q:'♕',r:'♖',b:'♗',n:'♘',p:'♙'};
    cx.fillStyle= c==='w' ? '#003366' : '#440044'; // 深色字體
    cx.textAlign='center'; cx.font='180px serif'; cx.fillText(s[t],128,220);
    
    const tex=new THREE.CanvasTexture(cv);
    const mat=new THREE.SpriteMaterial({map:tex});
    const sprite=new THREE.Sprite(mat);
    sprite.scale.set(0.8,1.2,1); 
    sprite.castShadow=true; // 讓 Sprite 也有影子 (Three.js 實驗功能，通常無效，但位置對就好)
    return sprite;
}

function syncPieces(){
    for(let sq in piecesMap) scene.remove(piecesMap[sq]); piecesMap={}; const b=game.board();
    for(let r=0;r<8;r++)for(let c=0;c<8;c++){const p=b[r][c];if(p){const sq=String.fromCharCode(97+c)+(8-r),s=createPieceSprite(p.type,p.color);s.position.set(c-3.5,0.7,r-3.5);scene.add(s);piecesMap[sq]=s;}}
}

// --- 交互 ---
function onMouseClick(e){if(isProcessing)return;mouse.x=(e.clientX/window.innerWidth)*2-1;mouse.y=-(e.clientY/window.innerHeight)*2+1;raycaster.setFromCamera(mouse,camera);const i=raycaster.intersectObjects(Object.values(tilesMap));if(i.length>0)handleInteraction(i[0].object.userData.square);}
function handleInteraction(sq){const p=game.get(sq);if(!selectedSquare){if(p&&p.color==='w'&&game.turn()==='w')selectSquare(sq);}else{if(p&&p.color==='w'){selectSquare(sq);return;}const m=game.move({from:selectedSquare,to:sq,promotion:'q'});if(m)animateMove(m);else{clearHighlights();selectedSquare=null;}}}

function selectSquare(sq){
    clearHighlights(); selectedSquare=sq;
    // 選中：亮金色
    tilesMap[sq].material.emissive.setHex(0xffaa00); tilesMap[sq].material.emissiveIntensity=0.8;
    game.moves({square:sq,verbose:true}).forEach(m=>{
        tilesMap[m.to].material.emissive.setHex(m.captured?0xff3300:0x00aaff); tilesMap[m.to].material.emissiveIntensity=0.5;
    });
}
function clearHighlights(){for(let sq in tilesMap){tilesMap[sq].material.emissive.setHex(0x000000);tilesMap[sq].material.emissiveIntensity=0;}}

function animateMove(m){
    isProcessing=true; clearHighlights();
    const s=piecesMap[m.from], e=tilesMap[m.to].position.clone(); e.y=0.7;
    if(m.captured&&piecesMap[m.to])scene.remove(piecesMap[m.to]);
    new TWEEN.Tween(s.position).to(e,400).easing(TWEEN.Easing.Quadratic.Out).onComplete(()=>{
        syncPieces(); updateStatus();
        if(game.game_over())return;
        if(game.turn()==='b')setTimeout(makeRandomAI,500);else isProcessing=false;
    }).start();
}
function makeRandomAI(){const ms=game.moves();if(ms.length===0)return;game.move(ms[Math.floor(Math.random()*ms.length)]);syncPieces();updateStatus();isProcessing=false;}
function updateStatus(){
    const t=document.getElementById('turn-txt');
    t.innerText=game.turn()==='w'?"YOUR TURN":"AI THINKING";
    t.style.color=game.turn()==='w'?"#00aaff":"#ffaa00";
    log(`Move: ${game.history().pop()}`);
}
function log(m){document.getElementById('move-log').innerText += `\n> ${m}`;}
function onResize(){camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);}

function animate(){
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();
    TWEEN.update(); controls.update();
    
    if(grassMat.userData.shader) grassMat.userData.shader.uniforms.time.value = t;
    if(window.cloudGroup) window.cloudGroup.rotation.y = t * 0.01;

    for(let sq in piecesMap){
        const s=piecesMap[sq], p=game.get(sq);
        if(p&&p.color==='w') s.position.y=0.7+Math.sin(t*3+s.id)*0.03;
    }
    renderer.render(scene,camera);
}

init();
</script>
</body>
</html>
