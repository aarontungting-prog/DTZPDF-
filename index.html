<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>霓虹西洋棋：浮空花園・絕對修復版</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/objects/Sky.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        .hud { position: absolute; color: #fff; text-shadow: 0 2px 5px rgba(0,0,0,0.8); pointer-events: auto; }
        #status-panel { top: 30px; right: 30px; text-align: right; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.2); }
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; color: #ffdd55; margin-bottom: 5px; }
        #turn-txt { font-size: 2.2rem; font-weight: 900; color: #fff; }
        #loading { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #111; color: #ffaa00; display: flex; justify-content: center; align-items: center; z-index: 999; font-size: 24px; font-weight: bold; transition: opacity 0.5s; }
    </style>
</head>
<body>

<div id="loading">載入浮空花園與實體棋子...</div>

<div id="ui" style="display:none;">
    <div id="status-panel" class="hud">
        <h1>FLOATING GARDEN</h1>
        <div id="turn-txt">BLUE TURN</div>
    </div>
</div>

<script>
let scene, camera, renderer, controls, raycaster, mouse, clock, composer;
let game = new Chess();
let piecesMap = {}; 
let selectedSquare = null, isProcessing = false;
let grassMat, treeLeafMat, cloudParticles = [];
const BOARD_HEIGHT = 12; // 棋盤懸浮高度

const CHESS_NAMES = { k: 'KING', q: 'QUEEN', r: 'ROOK', b: 'BISHOP', n: 'KNIGHT', p: 'PAWN' };

function init() {
    clock = new THREE.Clock();
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0xffddaa, 0.0015); // 溫暖日落霧
    scene.background = new THREE.Color(0x442211);

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 3000);
    camera.position.set(0, 35, 45);

    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 1.9; // 視角限制
    controls.minDistance = 10; controls.maxDistance = 200;
    controls.target.set(0, BOARD_HEIGHT, 0);

    setupLighting();
    setupPostProcessing();

    // 直接生成，不延遲太久
    createFloatingGarden(); // 新：生成綠地與樹
    createFloatingBoard();  // 新：生成懸浮棋盤 (無土塊)
    createClouds();
    syncPieces();           // 新：生成實體棋子

    // 關閉 Loading
    setTimeout(() => {
        document.getElementById('loading').style.opacity = 0;
        setTimeout(() => document.getElementById('loading').style.display = 'none', 500);
        document.getElementById('ui').style.display = 'block';
    }, 500);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    window.addEventListener('click', onMouseClick);
    window.addEventListener('resize', onResize);

    animate();
}

function setupLighting() {
    const ambient = new THREE.AmbientLight(0xffeedd, 0.8); // 很亮的環境光，確保東西看得到
    scene.add(ambient);

    const sunLight = new THREE.DirectionalLight(0xffaa33, 2.5);
    sunLight.position.set(-100, 80, -100);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.set(2048, 2048);
    const d = 200;
    sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d;
    sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
    scene.add(sunLight);

    const sky = new THREE.Sky(); sky.scale.setScalar(450000); scene.add(sky);
    const uniforms = sky.material.uniforms;
    uniforms['turbidity'].value = 8; uniforms['rayleigh'].value = 2;
    uniforms['mieCoefficient'].value = 0.005; uniforms['mieDirectionalG'].value = 0.8;
    uniforms['sunPosition'].value.copy(sunLight.position);
}

function setupPostProcessing() {
    const renderScene = new THREE.RenderPass(scene, camera);
    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.strength = 0.4; bloomPass.radius = 0.5; bloomPass.threshold = 0.8;
    composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderScene); composer.addPass(bloomPass);
}

// --- 1. 浮空花園 (綠色地面 + 樹木) ---
function createFloatingGarden() {
    // A. 綠色大草原 (實體地面)
    // 直接放在 y=0，棋盤在 y=12，這樣就是「棋盤浮在草原上」
    const groundGeo = new THREE.CylinderGeometry(180, 180, 5, 64);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x2d4c1e, roughness: 1.0 }); // 深綠色泥土
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.position.y = -2.5; // 讓頂面剛好在 y=0
    ground.receiveShadow = true;
    scene.add(ground);

    // B. 茂密的草 (Shader Grass)
    const bladeGeo = new THREE.PlaneGeometry(0.3, 1.2); bladeGeo.translate(0, 0.6, 0);
    grassMat = new THREE.MeshStandardMaterial({ color: 0x66aa33, side: THREE.DoubleSide });
    grassMat.onBeforeCompile = s => {
        s.uniforms.time={value:0}; s.vertexShader=`uniform float time;\n`+s.vertexShader;
        s.vertexShader=s.vertexShader.replace(`#include <begin_vertex>`, `vec3 transformed=vec3(position); float w=sin(time*2.0+position.x*0.5)*0.2*position.y; transformed.x+=w; #include <begin_vertex>`);
        grassMat.userData.shader=s;
    };
    const iGrass = new THREE.InstancedMesh(bladeGeo, grassMat, 20000);
    const dum = new THREE.Object3D();
    for(let i=0; i<20000; i++){
        const r = Math.random() * 170; // 鋪滿整個圓
        const a = Math.random() * Math.PI * 2;
        dum.position.set(Math.cos(a)*r, 0, Math.sin(a)*r);
        dum.rotation.y = Math.random() * Math.PI;
        dum.scale.setScalar(0.8 + Math.random());
        dum.updateMatrix();
        iGrass.setMatrixAt(i, dum.matrix);
    }
    iGrass.receiveShadow = true;
    scene.add(iGrass);

    // C. 樹木 (強制有樹幹)
    const treeGroup = new THREE.Group();
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 }); // 棕色樹幹
    const leafMat = new THREE.MeshStandardMaterial({ color: 0x228b22, flatShading: true }); // 森林綠葉

    // 樹幹幾何體
    const trunkGeo = new THREE.CylinderGeometry(0.6, 0.9, 4, 8);
    // 樹葉幾何體
    const leafGeo = new THREE.DodecahedronGeometry(3);

    for(let i=0; i<200; i++) {
        const r = 25 + Math.random() * 150; // 避開正中心，分佈在周圍
        const a = Math.random() * Math.PI * 2;
        const x = Math.cos(a)*r; 
        const z = Math.sin(a)*r;

        const tree = new THREE.Group();
        
        // 1. 樹幹 (明確加入)
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 2; // 高度 4 的一半，確保立在地上
        trunk.castShadow = true; trunk.receiveShadow = true;
        tree.add(trunk);

        // 2. 樹葉 (明確加入)
        const leaf = new THREE.Mesh(leafGeo, leafMat);
        leaf.position.y = 5; // 樹幹頂端
        leaf.castShadow = true; 
        tree.add(leaf);

        tree.position.set(x, 0, z);
        treeGroup.add(tree);
    }
    scene.add(treeGroup);
}

// --- 2. 懸浮棋盤 (無土塊) ---
function createFloatingBoard() {
    // 只有一個發光環，沒有圓柱土塊
    const ringGeo = new THREE.TorusGeometry(8, 0.2, 16, 64);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI / 2; 
    ring.position.y = BOARD_HEIGHT - 2; // 懸浮在下方
    scene.add(ring);
    
    // 能量粒子 (連接環與棋盤)
    const pGeo = new THREE.BufferGeometry();
    const pCount = 50;
    const pPos = new Float32Array(pCount * 3);
    for(let i=0; i<pCount; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = 7 + Math.random();
        pPos[i*3] = Math.cos(a)*r;
        pPos[i*3+1] = BOARD_HEIGHT - 2 + Math.random()*2;
        pPos[i*3+2] = Math.sin(a)*r;
    }
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    const pMat = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.1 });
    scene.add(new THREE.Points(pGeo, pMat));

    // Shader 棋盤 (無縫)
    const boardGeo = new THREE.BoxGeometry(8, 0.5, 8);
    const boardShaderMat = new THREE.ShaderMaterial({
        uniforms: { uColorWhite: { value: new THREE.Color(0xffeebb) }, uColorBlack: { value: new THREE.Color(0x553333) } },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0); }`,
        fragmentShader: `
            uniform vec3 uColorWhite; uniform vec3 uColorBlack; varying vec2 vUv;
            void main() {
                vec2 grid = floor(vUv * 8.0);
                float check = mod(grid.x + grid.y, 2.0);
                vec3 color = mix(uColorBlack, uColorWhite, check);
                gl_FragColor = vec4(color, 1.0);
            }
        `
    });
    const board = new THREE.Mesh(boardGeo, boardShaderMat);
    board.position.y = BOARD_HEIGHT; 
    board.receiveShadow = true; 
    board.userData = { isBoard: true }; // 點擊判定用
    scene.add(board);
    
    // 金屬邊框
    const border = new THREE.Mesh(new THREE.BoxGeometry(8.4, 0.4, 8.4), new THREE.MeshStandardMaterial({ color: 0x332211, roughness:0.4 }));
    border.position.y = BOARD_HEIGHT - 0.05; border.receiveShadow=true; scene.add(border);
}

// --- 3. 實體棋子 (確保可見) ---
function createSolidPiece(type, color) {
    const group = new THREE.Group();
    
    // 使用 MeshPhongMaterial，對光照反應更好，確保可見
    const mat = new THREE.MeshPhongMaterial({ 
        color: color === 'w' ? 0xffffff : 0x111111,
        shininess: 100, // 高光
        specular: 0x555555
    });
    
    const glowMat = new THREE.MeshBasicMaterial({ 
        color: color === 'w' ? 0x00ffff : 0xff0055 
    });

    // 底座
    const base = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 0.2, 32), mat);
    base.position.y = 0.1; base.castShadow = true; group.add(base);

    // 簡單幾何體構建
    if(type === 'p') { // Pawn
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.3, 0.6, 16), mat);
        body.position.y = 0.5; body.castShadow = true;
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.25), mat);
        head.position.y = 0.9; head.castShadow = true;
        group.add(body, head);
    } else if(type === 'r') { // Rook
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.8, 16), mat);
        body.position.y = 0.6; body.castShadow = true;
        const top = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.2, 16), mat);
        top.position.y = 1.1;
        group.add(body, top);
    } else if(type === 'n') { // Knight
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.5, 16), mat);
        body.position.y = 0.45;
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.5, 0.2), mat);
        head.position.set(0, 0.9, 0.1); head.rotation.x = -0.5;
        group.add(body, head);
    } else if(type === 'b') { // Bishop
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.3, 1.0, 16), mat);
        body.position.y = 0.7;
        const top = new THREE.Mesh(new THREE.SphereGeometry(0.1), glowMat);
        top.position.y = 1.3;
        group.add(body, top);
    } else if(type === 'q') { // Queen
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.35, 1.4, 16), mat);
        body.position.y = 0.9;
        const crown = new THREE.Mesh(new THREE.SphereGeometry(0.2), glowMat);
        crown.position.y = 1.7;
        group.add(body, crown);
    } else if(type === 'k') { // King
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.4, 1.6, 16), mat);
        body.position.y = 1.0;
        const cross = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 0.15), glowMat);
        cross.position.y = 1.95;
        group.add(body, cross);
    }

    return group;
}

function syncPieces() {
    // 先清空
    for(let key in piecesMap) {
        scene.remove(piecesMap[key]);
    }
    piecesMap = {};

    const board = game.board();
    for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
            const p = board[r][c];
            if(p) {
                const sq = String.fromCharCode(97+c) + (8-r);
                const mesh = createSolidPiece(p.type, p.color);
                // 修正座標: 棋盤中心是 (0, BOARD_HEIGHT, 0)
                mesh.position.set(c - 3.5, BOARD_HEIGHT + 0.25, (r - 3.5)); // 注意：Three.js Z軸向下增加
                scene.add(mesh);
                piecesMap[sq] = mesh;
            }
        }
    }
}

// --- 雲 ---
function createClouds() {
    const cv = document.createElement('canvas'); cv.width=64; cv.height=64;
    const cx = cv.getContext('2d'), g = cx.createRadialGradient(32,32,0,32,32,32);
    g.addColorStop(0, 'rgba(255, 200, 150, 0.4)'); g.addColorStop(1, 'rgba(0,0,0,0)');
    cx.fillStyle = g; cx.fillRect(0,0,64,64);
    const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(cv), transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
    
    for(let i=0; i<30; i++) {
        const cl = new THREE.Group();
        for(let j=0; j<20; j++) {
            const p = new THREE.Sprite(mat); 
            p.position.set((Math.random()-0.5)*40, (Math.random()-0.5)*15, (Math.random()-0.5)*40); 
            p.scale.setScalar(20+Math.random()*30); cl.add(p);
        }
        cl.position.set((Math.random()-0.5)*800, 150+Math.random()*50, (Math.random()-0.5)*800);
        scene.add(cl); cloudParticles.push(cl);
    }
}

// --- 交互 ---
function onMouseClick(e){
    if(isProcessing)return;
    mouse.x=(e.clientX/window.innerWidth)*2-1; mouse.y=-(e.clientY/window.innerHeight)*2+1;
    raycaster.setFromCamera(mouse,camera);
    const intersects = raycaster.intersectObjects(scene.children);
    for(let i=0; i<intersects.length; i++) {
        if(intersects[i].object.userData.isBoard) {
            const pt = intersects[i].point;
            // 轉換世界座標 -> 棋盤格子 (8x8)
            // 棋盤範圍 x: -4 ~ 4, z: -4 ~ 4
            const x = Math.floor(pt.x + 4); 
            const z = Math.floor(pt.z + 4);
            if(x>=0 && x<8 && z>=0 && z<8) {
                // z=0 是 rank 1? 不，Three.js Z軸正向是螢幕外。
                // 棋盤繪製時：row 0 (top) -> z = -3.5 (far)
                // row 7 (bottom) -> z = 3.5 (near)
                // 所以 z=0 對應 row=3 or 4.
                // 修正對應：row = z index.
                const c = x;
                const r = z; // r=0 -> rank 8 (top), r=7 -> rank 1 (bottom)
                // chess.js: a1 is c=0, r=7. a8 is c=0, r=0.
                const square = String.fromCharCode(97+c) + (8-r);
                handleInteraction(square);
                return;
            }
        }
    }
}
function handleInteraction(sq){const p=game.get(sq);if(!selectedSquare){if(p&&p.color==='w'&&game.turn()==='w')selectedSquare=sq;}else{if(p&&p.color==='w'){selectedSquare=sq;return;}const m=game.move({from:selectedSquare,to:sq,promotion:'q'});if(m)animateMove(m);else{selectedSquare=null;}}}
function animateMove(m){
    isProcessing=true; 
    const s=piecesMap[m.from]; 
    // 重新計算目標座標
    const col = m.to.charCodeAt(0) - 97;
    const row = 8 - parseInt(m.to[1]); // chess rank to array index
    const tx = col - 3.5;
    const tz = row - 3.5;

    if(m.captured&&piecesMap[m.to])scene.remove(piecesMap[m.to]);
    
    new TWEEN.Tween(s.position).to({x:tx, z:tz}, 500).easing(TWEEN.Easing.Quadratic.Out).start();
    new TWEEN.Tween(s.position).to({y: BOARD_HEIGHT + 2}, 250).easing(TWEEN.Easing.Cubic.Out).chain(
        new TWEEN.Tween(s.position).to({y: BOARD_HEIGHT + 0.25}, 500).easing(TWEEN.Easing.Bounce.Out).onComplete(()=>{
            syncPieces(); updateStatus(); if(game.game_over())return; if(game.turn()==='b')setTimeout(makeRandomAI,500);else isProcessing=false;
        })).start();
}
function makeRandomAI(){const ms=game.moves();if(ms.length===0)return;game.move(ms[Math.floor(Math.random()*ms.length)]);syncPieces();updateStatus();isProcessing=false;}
function updateStatus(){const t=document.getElementById('turn-txt');t.innerText=game.turn()==='w'?"BLUE TURN":"AI TURN";t.style.color=game.turn()==='w'?"#00e5ff":"#ff0055";}
function onResize(){camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);composer.setSize(window.innerWidth,window.innerHeight);}

function animate(){
    requestAnimationFrame(animate); const t=clock.getElapsedTime(); TWEEN.update(); controls.update();
    if(grassMat&&grassMat.userData.shader)grassMat.userData.shader.uniforms.time.value=t;
    cloudParticles.forEach(c => { c.rotation.y += 0.0002; });
    composer.render();
}
init();
</script>
</body>
</html>
